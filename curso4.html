<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Curso detallado sobre el Template de Robótica en PacDrive3. Aprende a configurar hasta 4 robots sin necesidad de programación, modificar referencias y gestionar pantallas de visualización con recursos educativos especializados.">
	<meta name="keywords" content="curso PacDrive3, template robótica PacDrive3, configuración de robots, referencia en robótica, pantallas de visualización PacDrive3, automatización robótica, formación en PacDrive3">
	<title>Portal PacDrive | El Template de Robótica configurable de PacDrive3 </title>
	<link rel="icon" href="assets/icons/favicon.png" type="image/png" sizes="512x512">
	<link rel="apple-touch-icon" href="assets/icons/apple-touch-icon-180x180.png" sizes="180x180">
	<link rel="apple-touch-icon" href="assets/icons/apple-touch-icon-152x152.png" sizes="152x152">
	<link rel="apple-touch-icon" href="assets/icons/apple-touch-icon-120x120.png" sizes="120x120">
	<link rel="apple-touch-icon" href="assets/icons/apple-touch-icon-76x76.png" sizes="76x76">	
    <link rel="stylesheet" href="css/styles.css">
	
	<!-- Google tag (gtag.js) -->
	<script async src="https://www.googletagmanager.com/gtag/js?id=G-XYDH0QS9L0"></script>
	<script>
	  window.dataLayer = window.dataLayer || [];
	  function gtag(){dataLayer.push(arguments);}
	  gtag('js', new Date());

	  gtag('config', 'G-XYDH0QS9L0');
	</script>	
</head>

<body>
	<!-- Menú principal -->
    <header>
        <nav aria-label="Menú principal">
			<button id="openMenuButton" class="open-menu-button">☰</button>
            <ul>
                <li><a href="index.html" aria-label="Ir a Inicio">Inicio</a></li>
                <li><a href="cursos.html" aria-label="Ir a Cursos">Cursos</a></li>
                <li><a href="#info" aria-label="Ir a Legal">Legal</a></li>
            </ul>
        </nav>
    </header>	
	
	<!-- Menú lateral -->
	<aside id="sideMenu" class="side-menu" aria-label="Menú de contenido">
		<div class="side-menu-header">	
			<h2>CONTENIDO</h2>	
			<button id="closeMenuButton" class="close-menu-button" aria-label="Cerrar menú lateral">&times;</button>
		</div>
		<div class="menu-content">
			<ul>
				<li><a href="#" onclick="showCapitulo(0)" aria-label="Ir a Introducción">Introducción</a></li>
				<li><a href="#" onclick="showCapitulo(1)" aria-label="Ir a Cambiar el número de robots">Cambiar el número de robots</a></li>
				<li><a href="#" onclick="showCapitulo(2)" aria-label="Ir a Cambiar la referencia del robot">Cambiar la referencia del robot</a></li>
				<li><a href="#" onclick="showCapitulo(3)" aria-label="Ir a Descripción pantallas Visualización">Descripción pantallas Visualización</a></li>				
				<li><a href="#" onclick="showCapitulo(4)" aria-label="Ir a Modo Impulsos (básico)">Modo Impulsos (básico)</a></li>
				<li><a href="#" onclick="showCapitulo(5)" aria-label="Ir a Modo Impulsos (avanzado)">Modo Impulsos (avanzado)</a></li>
				<li><a href="#" onclick="showCapitulo(6)" aria-label="Ir a Modo Aprendizaje">Modo Aprendizaje</a></li>
				<li><a href="#" onclick="showCapitulo(7)" aria-label="Ir a Modo Limpieza">Modo Limpieza</a></li>								
				<li><a href="#" onclick="showCapitulo(8)" aria-label="Ir a Visualizador 3D">Visualizador 3D</a></li>
				<li><a href="#" onclick="showCapitulo(9)" aria-label="Ir a El simulador de ítems">El simulador de ítems</a></li>				
				<li><a href="#" onclick="showCapitulo(10)" aria-label="Ir a Operación Giro Asíncrono">Operación Giro Asíncrono</a></li>
				<li><a href="#" onclick="showCapitulo(11)" aria-label="Ir a Operación CNC">Operación CNC</a></li>				
				<li><a href="#" onclick="showCapitulo(12)" aria-label="Ir a Reglas selección de ítems">Reglas selección de ítems</a></li>
				<li><a href="#" onclick="showCapitulo(13)" aria-label="Ir a Tipo entrega en punto fijo">Tipo entrega en punto fijo</a></li>				
				<li><a href="#" onclick="showCapitulo(14)" aria-label="Ir a Tipo entrega en caja">Tipo entrega en caja</a></li>
				<li><a href="#" onclick="showCapitulo(15)" aria-label="Ir a Tipo entrega en cangilones">Tipo entrega en cangilones</a></li>
				<li><a href="#" onclick="showCapitulo(16)" aria-label="Ir a Reparto carga entre robots">Reparto carga entre robots</a></li>
				<li><a href="#" onclick="showCapitulo(17)" aria-label="Ir a Ajuste trayectoria en automático">Ajuste trayectoria en automático</a></li>
				<li><a href="#" onclick="showCapitulo(18)" aria-label="Ir a Funcionalides IoT">Funcionalides IoT</a></li>
				<li><a href="#" onclick="showCapitulo(19)" aria-label="Ir a Gestión de Recetas">Gestión de Recetas</a></li>				
			</ul>
		</div>
	</aside>

	<!-- Superposición para bloquear el scroll y las interacciones cuando está el menú lateral abierto-->
	<div id="overlay" class="overlay"></div>

    <main>
		<section class="section-container">
			<!-- Titular de la sección -->
			<h1 class="section-title course-title">El Template de Robótica</h1>

			<!-- Capítulo 1: INTRODUCCION GENERAL -->
			<article class="capitulo-container" id="capitulo1">
				<iframe 
					src="https://www.youtube.com/embed/Ye8kGMEPsC0?modestbranding=1&rel=0&enablejsapi=1" 
					frameborder="0" 
					loading="lazy"
					allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" 
					allowfullscreen 
					aria-label="Vídeo que muestra una presentación general de la plataforma de desarrollo de aplicaciones multirrobot."> 
				</iframe>
		
				<section class="transcripcion-container">
					<div class="transcripcion-header" data-leccion="Lección 1">
						<span class="transcripcion-icon" aria-hidden="true">▶</span>
						<span class="transcripcion-text">Transcripción</span>
					</div>
					<div class="transcripcion-content">
						<p>Bueno, básicamente lo que se presenta es una herramienta software que intenta acelerar el desarrollo de aplicaciones multirrobot, aplicaciones en las que intervengan de uno hasta cuatro robots. El objetivo principal sería intentar potenciar las ventas de Schneider Electric, que es la empresa para la cual presto mis servicios, intentando llegar a un mayor número de clientes, abaratando los costes, reduciendo los tiempos de desarrollo, haciendo el desarrollo más sencillo y flexibilizando la producción utilizando tecnologías habilitadoras de la Industria 4.0 que aporten valor añadido a las máquinas que utilicen la herramienta propuesta.</p>
						<p>Si echamos un vistazo al mercado, vemos que existe un gran número de fabricantes y proveedores de soluciones robóticas, y que cada uno de ellos utiliza su propia filosofía de trabajo. Así, atendiendo a los lenguajes de programación, vemos que algunos fabricantes utilizan un lenguaje propietario. Son lenguajes que han desarrollado ellos para sus productos. Están muy bien pensados para las aplicaciones que quieren atacar, son lenguajes muy evolucionados, pero que, por contra, dejan un poco cojo lo que es la automatización del resto de la máquina. Son lenguajes que necesitan personal especializado.</p>
						<p>Otros fabricantes optan por una plataforma única que integre dos lenguajes: uno para resolver la parte de automatización de la máquina y otro para resolver la parte robótica de la máquina. Finalmente, existen también otros fabricantes que utilizan un entorno de desarrollo único con un lenguaje de desarrollo también único que sirve tanto para la parte de automatización como para la parte robótica.</p>
						<p>Con el tema de los controladores pasa algo similar. Hay fabricantes que optan por una arquitectura hardware hecha a medida para sus productos, y para la automatización del resto de la máquina pues prefieren utilizar controladores y autómatas de otros fabricantes. ¿Qué ocurre? Que cuando se intenta hacer una máquina completa, pues, ambos sistemas tienen que convivir dentro de la misma máquina y comunicarse de alguna manera, bien por entradas/salidas digitales o bien por comunicaciones u otros medios. Son soluciones muy caras porque implican dos arquitecturas distintas conviviendo con dos lenguajes de desarrollo distintos. Por eso, hay fabricantes que optan por una solución genérica, una arquitectura hardware genérica que sirva tanto para la parte robótica como para máquinas que sean mixtas, que tengan parte robótica y parte de automatización; máquinas que solo interese la automatización y máquinas, pues, del método tradicional que interese comunicarse con un controlador externo para la parte robótica.</p>
						<p>Bien, ¿Qué es lo que se propone? Lo que se propone es utilizar una arquitectura hardware de tipo genérico, capaz de abordar tanto las secciones robóticas de una máquina como el resto de esta, las que no tienen nada que ver con la robótica. Esta arquitectura hardware se programa mediante una plataforma de desarrollo que sigue el estándar IEC 61131/3, que es un entorno, pues, que está bastante, está bastante extendido dentro del mundo industrial, sobre el que se monta la solución propuesta, que se basa en un entorno totalmente gráfico y parametrizable, de manera que no haga falta o se utilice lo menos posible la programación, a fin de poder acercarnos a todo tipo de desarrolladores, tanto los que tengan un alto nivel de programación como los que no lo tengan tanto.</p>
						<p>La solución propuesta incluye, pues, múltiples modos de trabajo (los más habituales) e incluye múltiples opciones de simulación para el comportamiento de la máquina, pues, ante diversas entradas de producto, tanto en 2D como en 3D. Incluye funcionalidades de control numérico y fabricación aditiva, y también de IoT. Todo esto se describe con más detalle más adelante. Además, facilidades a nivel de automatización, de manera que mediante el uso de los lenguajes clásicos para la automatización de máquina se pueda interactuar de una forma lo más sencilla posible con la parte más de robótica.</p>
						<p>Finalmente, la arquitectura software sobre la que se construye la solución propuesta está basada en un sistema jerárquico multinivel y totalmente modular, de manera que la máquina se describe en un nivel superior. En un nivel intermedio se van describiendo o se van desarrollando las distintas secciones de esta máquina, y en un nivel inferior, pues, los elementos más de campo, como los robots, los motores, las cintas, etc. De esta manera, somos capaces de abordar todo tipo de máquinas, desde las más sencillas hasta las más complejas.</p>
						<p>En cuanto a los sectores objetivo, como es imposible abarcar todo el espectro de aplicaciones que nos podemos encontrar en la industria, nos vamos a centrar solamente en un pequeño número de sectores. Básicamente, el más importante que va a cubrir la herramienta propuesta es el empaquetado rápido, que es básicamente ir a coger el producto de un sitio y dejarlo en otro. También otras aplicaciones clásicas serían la clasificación, el control de calidad, el paletizado y se intentará también tocar algo de material working, esto es, que el robot vaya a por un producto y realice una operación sobre él, por ejemplo, un taladrado, un biselado, que lo pinte, que dosifique algo encima de él, etc.</p>
						<p>Además del uso puramente de desarrollo puramente industrial, también se intenta que la herramienta sirva para tareas de promoción. Es decir, ir a visitar a un cliente, por ejemplo, y mostrarle las posibilidades de su máquina incluso antes de fabricar la máquina, para convencerle básicamente de que su solución es posible o, también, pues que sirva pues para realizar vídeos divulgativos u otro tipo de operaciones similares, y también, por supuesto, para la formación. Es decir, que sirva para mostrar las posibilidades de todo lo que integra la herramienta ¿no? de lo que es robótica, CNC, IoT, pues a una nueva generación de técnicos.</p>
						<p>Respecto al tipo de robots, la herramienta propuesta es compatible únicamente con los de tipo Delta 3D, es decir, los que se mueven en los tres ejes cartesianos. Simplemente hemos de indicar el modelo de robot a utilizar y la herramienta se autoadaptará a todas sus características, límites software, etc. No obstante, la plataforma de desarrollo de aplicaciones multirrobot también podría llegar a trabajar con otros tipos de robots como los Delta 2D, los SCARA, los cartesianos, algunos tipos de robots articulados… simplemente modificando parte de su código para incluir la transformada adecuada. Y luego tenemos otra serie de robots, como los antropomórficos o, por ejemplo, los colaborativos, que quedarían totalmente fuera del alcance de la herramienta debido a limitaciones hardware y también software.</p>
						<p>Bien, la herramienta incluye una serie de facilidades para configurar la aplicación. Las más importantes son definir el tipo de robot que se va a emplear mediante un cómodo listado que incluye una serie de filtros que, pues, permiten localizar la referencia más adecuada. Podemos también modificar el sistema de coordenadas del robot tanto lineal como angularmente. Por supuesto también podemos hacer lo mismo con el TCP (el punto central de la herramienta) que, originalmente, se encuentra en el centro del plato donde se va a mecanizar pero que podemos, pues, desplazar para que coincida con la superficie de una ventosa. Naturalmente también las dos cintas, la cinta de recogida y la cinta de entrega, pueden ser modificadas indicando, pues, su sentido de avance y su posición respecto al centro del robot.</p>
						<p>En cuanto a las cintas, podemos modificar sus dimensiones (su largo, su ancho) y también ciertas zonas críticas de las mismas, por ejemplo, la zona de trabajo que va a utilizar el robot, tanto para recoger el producto como para entregarlo y algunas zonas de calidad que van a ser utilizadas para comprobar si el producto procesado es OK o no es OK y, también, pues evidentemente, los límites software de cada uno de los robots para evitar que el robot las atraviese.</p>
						<p>También se incluyen una serie de funcionalidades para el ajuste de la cámara de visión. Para ello se hace uso de un ejemplo real utilizando una cámara de visión Cognex conectada al controlador mediante un bus de campo EthernetIP. Mediante el uso de un panel específico y un procedimiento descrito en la memoria técnica, es posible encontrar el cero de coordenadas de cada una de las cámaras utilizadas y ver su alineación respecto al sistema de coordenadas del robot, tanto lineal como angularmente. Existen una serie de parámetros, también, que permiten ajustar el disparo de la cámara, por ejemplo, cada cierto avance de la cinta a la que está asociada y también el ancho del pulso de disparo.</p>
						<p>Y finalmente, indirectamente relacionado con este tema, existen también unos parámetros que nos permiten descentrar el punto de cogida del ítem un poquito a la derecha, un poquito a la izquierda o con cierto ángulo ¿vale? Es aplicar una serie de offsets para intentar corregir cualquier posible pequeño error de la cámara o bien porque nos interesa no ir al centro sino a una posición determinada tal como se ve aquí, en estos dibujos.</p>
						<p>Por supuesto también se incluyen muchas funcionalidades manuales, sobre todo útiles durante los inicios de las puestas en marcha para comprobar, pues, los sentidos del movimiento, si los motores corresponden con los ejes, etcétera. Las más habituales son los movimientos de los propios ejes, es decir, el propio rotor del motor, los movimientos de los ejes cartesianos para comprobar si realmente, cuando le damos a mover en X o en Y, se mueven en esos sentidos. Podemos definir velocidades, rampas, comprobar el estado del sistema, podemos memorizar una serie de puntos para formar a través de ellos una determinada trayectoria. Una vez memorizados estos puntos, podemos movernos a través de la trayectoria que forman. Podemos obtener información sobre la trayectoria formada, por ejemplo, su longitud, dada cierta velocidad, cuánto tiempo falta para concluirla y también información de los segmentos que se encuentran en el almacén de trayectorias.</p>
						<p>También se incluye un panel al que se le ha llamado "aprendizaje" y que sirve para comprobar el correcto funcionamiento del robot ya de una forma más automatizada, menos manual. Desde este panel, que también está compartido con ciertas operaciones en modo manual, podemos, como os he comentado anteriormente, memorizar los puntos destino de cada uno de los segmentos que conformarán una trayectoria. A partir de ahí, una vez definidos estos puntos, podemos ir ejecutando o ir ordenando el desplazamiento del robot a cada uno de estos puntos. Si lo hacemos suficientemente deprisa, podemos con ellos formar una trayectoria. Igualmente, del mismo modo que se ha hecho en el modo manual, podemos obtener información de la trayectoria y, lo más interesante, es que podemos automatizar esta trayectoria. Podemos hacer ciclos repetitivos de ir, dejar, volver, coger, volver, dejar, incluyendo los tiempos de apertura y cierre de la pinza para comprobar si el ciclo que obtenemos es el que desea el cliente. Y también, por supuesto, tenemos una serie de parámetros para modificar las velocidades, tanto de ida como de vuelta como, bueno, cualquier tipo de parámetro cinemático.</p>
						<p>Como no podía ser de otro modo, también existen múltiples funcionalidades de simulación, entre ellas está definir, por ejemplo, el número de ítems que se van a generar en cada disparo. Tenemos dos modos de simulación: el modo, digamos, que manual, cada vez que pulsemos un botón, o el modo automático, esto es, utilizar los mismos parámetros que utilizaría la cámara real en cuanto al avance de cinta para generar los disparos del simulador. Podemos definir la aleatoriedad de los ítems que se van a generar y utilizar los parámetros de disparo de la cámara real para disparar el simulador. De este modo, por ejemplo, podemos comprobar de una forma muy sencilla el comportamiento de la máquina según la llegada de ítems, tal como nos describa el cliente que van a llegar.</p>
						<p>Entre las funciones de configuración del modo automático, si bien no se cubren el 100% de las posibilidades que nos podemos encontrar en la industria, sí se tienen en cuenta las más importantes. Por ejemplo, se incluyen tres tipos de operación: modo Pick and Place, modo Giro Asíncrono y modo CNC. Se incluyen diversas reglas de selección para que el robot sea capaz de priorizar el ítem a procesar entre varios disponibles. Existen tres tipos de entrega: la entrega a punto fijo, que nos permite realizar mosaicos; la entrega en caja, que nos permite obtener un ítem de la cinta de recogida e introducirlo en una caja en movimiento, que se encuentre también o pueda poseer distintos ángulos y posiciones; y la entrega en cinta de cangilones, una cinta sin fin con una serie de huecos y el robot debe coger un ítem de la cinta de recogida y entregarlo en un hueco libre.</p>
						<p>En el caso de que se tengan o se utilice más de un robot, existen tipos de reparto de carga para que la carga se reparta entre los dos robots por igual. Podemos hacerlo por zona de la cinta en la que circula el ítem, asignando cada zona a un robot, o por la categoría del propio ítem, asignando una categoría u otra a un robot u otro. Y por supuesto, tenemos la configuración de la trayectoria tanto a nivel de posiciones como de velocidades.</p>
						<p>La herramienta propuesta es compatible con un programa externo que se encarga de visualizar en tres dimensiones el comportamiento de la máquina. Este programa externo, de momento, solamente es compatible con robots Scara y Delta, algunas formas primitivas de, para, digamos, formar los ítems (cubos, esferas, cilindros), y la visualización de cintas, de cintas transportadoras. Permite, por ejemplo, ver el espacio de trabajo del robot, que sería esta parte de aquí. Permite visualizar la trayectoria del TCP del robot, aunque aquí no se vea del todo bien, pero se ve que a medida que el robot se mueve se va creando como una especie como de… como de huella ¿no?, como de trayectoria. Y finalmente nos muestra una serie de información básica del robot, su posición básicamente y poco más. Esto es especialmente útil en acciones de formación, de promoción y de desarrollo offline porque nos permite ver un poco qué es lo que va a hacer la máquina antes de tener la máquina.</p>
						<p>La herramienta propuesta cuenta con una serie de funcionalidades más propias a otros campos como el control numérico o la fabricación aditiva. Esto se ha hecho para dotarla de una mayor flexibilidad productiva. En una aplicación robótica estándar lo que suele suceder es que las trayectorias suelen estar preprogramadas en el interior del controlador de modo que, si las deseamos modificar, hemos de modificar el programa del controlador.</p>
						<p>Aquí lo que se pretende es poder tener cierta libertad para añadir nuevas trayectorias al sistema a fin de, por ejemplo, coger una pieza original y mecanizarla con formas distintas, formas que no han sido preestablecidas previamente en el controlador. También nos interesa interactuar con la herramienta para activarla o desactivarla en distintos puntos de la nueva trayectoria creada. Con este tipo de flexibilidad de programación, lo que podemos hacer es cosas como, por ejemplo, dibujar patrones encima de, por ejemplo, de empanadas simplemente para determinar cuál es su relleno.</p>
						<p>Aquí tenemos algunos ejemplos. Para realizar este tipo de operaciones se utiliza un lenguaje comúnmente utilizado en el control numérico o la fabricación aditiva, que se llama G-code. Mediante el uso de este lenguaje, podemos simplemente programar una secuencia de órdenes, de trayectorias y de activaciones o desactivaciones de la herramienta en un fichero de texto para luego introducirlo en el controlador vía, por ejemplo, un servidor FTP. Con esto modificaríamos la trayectoria seguida por el robot pero, además, también los momentos en los cuales se activa y desactiva la herramienta.</p>
						<p>Además, tenemos la posibilidad de decidir cuánto tiempo tiene que transcurrir desde que se activa o desactiva la herramienta hasta que el movimiento continúa. Esto nos da una gran flexibilidad a la hora de crear nuevas trayectorias o nuevas operaciones sobre el objeto a procesar.</p>
						<p>En cuanto a las funcionalidades IoT, la aplicación garantiza un canal de comunicaciones con el exterior basado en OPC UA por ser uno de los protocolos más comúnmente utilizados en el mundo industrial. A través de este canal de comunicaciones podemos publicar una serie de datos extraídos de la aplicación, por ejemplo, el número de operaciones realizadas correctamente por el robot, su recorrido acumulado, el tiempo que lleva en modo automático, por ejemplo, o produciendo. Y a partir de aquí se suministran también una serie de ejemplos para manipular esta información del controlador desde, por ejemplo, un gateway en Node-RED y publicarla vía protocolo MQTT, pues, hacia un software basado en la nube.</p>
						<p>También se suministra el ejemplo de este, de uso de un software basado en la nube, un software de Schneider Electric para realizar operaciones de supervisión de la producción, de la productividad de cada uno de los robots, temas de mantenimiento para ver qué robot necesita un mantenimiento antes que otro, basándose, pues, por ejemplo, en el número de maniobras o en la distancia recorrida.</p>
						<p>Y finalmente, como extra, se facilita también algún ejemplo de uso de APIs para reporting. Casi todos los softwares basados en la nube contienen algún tipo de acceso a la información histórica que contienen. En este caso, el software utilizado, pues, tiene una API y, a través de un lenguaje de interrogación que se llama GraphQL, podemos desde Node-RED extraer información de la nube y grabarla en un fichero CSV. Luego, este fichero CSV podemos abrirlo en Excel y analizar los datos que hemos decidido leer de la nube. También podemos hacer lo mismo con, directamente desde Excel, desde una maniobra realizada en Visual Basic para aplicaciones.</p>
						<p>Las posibilidades son infinitas y la verdad es que es muy difícil sintetizarlo todo en una, en un par de slides.</p>						
					</div>
				</section>
				
				<section class="aspectos-container">
					<h3>Aspectos Clave</h3>
					<p>El video comienza explorando las tendencias actuales en el desarrollo de aplicaciones robóticas, destacando cómo diferentes proveedores abordan los desafíos de la automatización y la robótica. En este contexto, se identifican tres enfoques: algunos optan por emplear hardware y software específicos para la parte robótica, junto con hardware y software genéricos para la automatización del resto de la máquina, lo que puede complicar la integración, aumentar los costos y requerir personal especializado en ambos ámbitos; otros, por un controlador único que gestiona ambas funciones, aunque aún con lenguajes de programación separados; y finalmente, algunos apuestan por entornos de desarrollo de propósito general unificados, con un único controlador y un único lenguaje de programación, con el objetivo de simplificar la programación y facilitar la integración de estas dos áreas.</p>
					<p>La herramienta presentada en el curso surge como una solución innovadora diseñada para superar las limitaciones de estos enfoques tradicionales. En lugar de depender de lenguajes de programación complejos, esta herramienta se basa en una configuración de parámetros, lo que permite un desarrollo más accesible y menos dependiente de habilidades avanzadas de programación. Esta aproximación tiene como objetivo reducir costos, acortar tiempos de desarrollo y facilitar una integración más flexible y económica, alineándose con las tendencias de la Industria 4.0.</p>
					<p>El video también subraya la ventaja de utilizar una arquitectura hardware genérica que puede manejar tanto la robótica como las secciones de automatización de una máquina. Esto contrasta con las soluciones más costosas y complicadas que requieren la coexistencia de múltiples sistemas y lenguajes de desarrollo. La propuesta hardware-software busca ofrecer una solución modular y escalable que aborde una amplia gama de aplicaciones, desde el Packaging hasta el Material Working, mediante una plataforma que permite configuraciones gráficas y parametrizables para adaptarse a diversos tipos de robots y aplicaciones industriales.</p>
					<p>Te invitamos a unirte a esta formación donde podrás conocer en detalle cómo esta herramienta puede transformar el desarrollo de tus aplicaciones robóticas. Aprovecha la oportunidad de aprender a fondo sobre sus funcionalidades, configuraciones y ventajas, y cómo puede ayudarte a optimizar tus procesos productivos. </p>
				</section>	
			</article>

			<!-- Capítulo 2: Configurar número de robots -->
			<article class="capitulo-container" id="capitulo2" style="display:none;">
				<iframe 
					src="https://www.youtube.com/embed/hedSwOl6yJs?modestbranding=1&rel=0&enablejsapi=1" 
					frameborder="0" 
					loading="lazy"
					allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" 
					allowfullscreen 
					aria-label="Vídeo que muestra cómo modificar la cantidad total de robots que nuestra aplicación controlará."> 
				</iframe>
			
				<section class="transcripcion-container">
					<div class="transcripcion-header" data-leccion="Lección 2">
						<span class="transcripcion-icon" aria-hidden="true">▶</span>
						<span class="transcripcion-text">Transcripción</span>
					</div>
					<div class="transcripcion-content">
						<p>En este vídeo veremos cómo modificar la cantidad total de robots que nuestra aplicación controlará. El punto de partida, tal como vemos, sería una situación en la que tenemos 4 robots y deseamos bajar a 2 robots. Antes de hacer el cambio, se tiene que explicar que el código asociado a cada robot, aunque estos estén desactivados, se está ejecutando y esto consume una serie de recursos. Si vamos a ver, por ejemplo, el código asociado al robot número 3, vemos que efectivamente está siendo ejecutado; hay una serie de código y una serie de recursos que están involucrados en el proceso.</p>
						<p>Entonces, como nuestro objetivo es eliminar los robots número 3 y 4, simplemente salimos a "offline", nos vamos a la carpeta de "Robótica", a la subcarpeta "Control Robots" y al objeto “GVL_Robots”. Accedemos a la constante global "gc_iMaxNrRobots" y simplemente hemos de modificar este 4 por un 2 y, ahora, hacemos una carga con download.</p>
						<p>Bien, mientras dura la carga, ya que tardará un pelín, hay que indicar de que podría parecer más normal que estos parámetros estuvieran en el panel de configuración, puesto que lo que estamos haciendo es configurar la aplicación. Sin embargo, al final, se ha optado por ponerlos en lo que es el interior del código como constantes globales, pues afectan de una forma muy crítica a elementos hardware de la aplicación, que por otra parte ya conocemos durante la calificación de la máquina. Por tanto no van a cambiar durante lo que es la fase de desarrollo de lo que es la aplicación.</p>
						<p>Bien, esto parece que ya se está enviando… ya lo tenemos. Le damos a "play", volvemos al panel de modo automático de trabajo y vemos que efectivamente, nuestra aplicación, que inicialmente tenía 4 robots, ahora solo representa 2. Además, si intentamos acceder al robot 3, vemos que ya no nos deja (solo tenemos 2). Y si comprobamos el código asociado al robot número 3, que hemos eliminado, vemos que efectivamente este código no se está ejecutando, por tanto, no existe consumo de recursos.</p>
						<p>Lo que hemos hecho es simplemente eliminar del control 2 robots, el 3 y 4, pero no hemos modificado para nada el código de lo que es la plataforma de desarrollo multirrobot. El código sigue existiendo, solo que no se ejecuta y, por tanto, no consume recursos.</p>
					</div>
				</section>
				
				<section class="aspectos-container">
					<h3>Aspectos Clave</h3>
					<p>La plataforma de desarrollo multirrobot permite gestionar aplicaciones que utilicen entre 1 y 4 robots. Por defecto, está configurada para trabajar con 4 robots.</p>
					<p>El número de robots a utilizar debe establecerse en el código modificando el valor de una constante. No es posible cambiar este número en tiempo de ejecución a través de los parámetros disponibles en las pantallas de configuración ni desde una HMI.</p>
					<p>El código correspondiente a los robots no utilizados permanecerá intacto pero no será ejecutado por lo que no consumirá recursos del controlador</p>
				</section>	
			</article>

			<!-- Capítulo 3: Configurar referencia de robots -->
			<article class="capitulo-container" id="capitulo3" style="display:none;">
				<iframe 
					src="https://www.youtube.com/embed/RArm8MBSBnw?modestbranding=1&rel=0&enablejsapi=1" 
					frameborder="0" 
					loading="lazy"
					allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" 
					allowfullscreen 
					aria-label="Vídeo que muestra cómo modificar la referencia del robot seleccionado."> 
				</iframe>
			
				<section class="transcripcion-container">
					<div class="transcripcion-header" data-leccion="Lección 3">
						<span class="transcripcion-icon" aria-hidden="true">▶</span>
						<span class="transcripcion-text">Transcripción</span>
					</div>
					<div class="transcripcion-content">
						<p>En este vídeo veremos cómo modificar la referencia del robot seleccionado. Tomaremos el robot número 2, que tiene un radio de trabajo determinado, y buscaremos una referencia de un robot que tenga un radio de trabajo mayor.</p>
						<p>El primer paso es seleccionar el robot que deseamos cambiar. Nos venimos a la sección superior y, en el selector de robots, escogemos el número 2. Como confirmación, veremos que su radio de trabajo, o su área de trabajo, mejor dicho, queda resaltada en azul.</p>
						<p>Ahora nos vamos al panel de configuración. Nos aseguramos que efectivamente el robot número 2 es el que vamos a modificar y hacemos clic en su referencia actual. En el panel que se nos abre, veremos una lista con todas las posibles referencias compatibles con la plataforma de desarrollo de aplicaciones multirrobot y una de ellas, hay una serie de filtros, uno de ellos, nos indica el radio de trabajo. Vamos a escoger un radio de 800 mm. Vemos que automáticamente las referencias que no cumplen con estos filtros quedan desactivadas, y solo se nos activan cuatro de ellas.</p>
						<p>Escogeremos aquella que más encaje con nuestras necesidades, por ejemplo, esta, que quedará automáticamente resaltada en amarillo. Esta es nuestra selección, pero aún no hemos hecho realmente el cambio. El robot realmente activo, el robot número 2 realmente activo, sigue siendo este de aquí, resaltado con un trazo un poco más grueso, y el deseado es el resaltado con un fondo en amarillo.</p>
						<p>Para que este cambio tenga validez, hemos de reiniciar el controlador. Apretamos aquí en "Reiniciar" y, tras unos breves instantes en los que la visualización quedará desactivada, el sistema se reiniciará automáticamente. Salimos del modo online, volvemos a entrar para reactivar las visualizaciones, nos vamos al robot número 2 y vemos que, efectivamente, el modelo ha sido modificado. Y para confirmarlo, nos vamos al panel de modo automático y ya vemos que el radio de trabajo es mucho mayor que el que tenía antes.</p>
					</div>
				</section>
				
				<section class="aspectos-container">
					<h3>Aspectos Clave</h3>
					<p>El primer paso consiste en seleccionar, mediante el selector ubicado en la sección superior, el número del robot cuya referencia se desea modificar. Para mayor seguridad, se recomienda acceder al panel de modo automático para comprobar el color del área de trabajo de los robots, lo que permitirá identificar con certeza cuál es el activo. Este procedimiento es crucial para asegurar que los cambios se apliquen al robot correcto, evitando posibles errores en la configuración.</p>
					<p>Para acceder a la pantalla de cambio de referencia, dirígete al panel de configuración y pulsa sobre la imagen del robot o su referencia. Desde allí, podrás seleccionar la referencia deseada de la lista de opciones disponibles o utilizar diversos filtros (radio de trabajo, con o sin eje de giro, etc.) para aislar las que mejor se ajusten a la aplicación.</p>
					<p>Para que los cambios tengan efecto, es necesario reiniciar el controlador. Este paso garantiza que la nueva configuración se aplique correctamente.</p>
				</section>	
			</article>

			<!-- Capítulo 4: Descripción pantallas aplicación -->
			<article class="capitulo-container" id="capitulo4" style="display:none;">
				<iframe 
					src="https://www.youtube.com/embed/5pyYlC0y8O4?modestbranding=1&rel=0&enablejsapi=1" 
					frameborder="0"
					loading="lazy"
					allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" 
					allowfullscreen 
					aria-label="Vídeo que describe la composición de las pantallas de visualización utilizadas por la aplicación."> 
				</iframe>

				<section class="transcripcion-container">
					<div class="transcripcion-header" data-leccion="Lección 4">
						<span class="transcripcion-icon" aria-hidden="true">▶</span>
						<span class="transcripcion-text">Transcripción</span>
					</div>
					<div class="transcripcion-content">
<!-- FALTA -->			<p>En este vídeo se describirá la composición de las pantallas de visualización utilizadas por la aplicación. Para acceder a ellas, haremos doble clic en "Vis_principal" o bien, si no estamos utilizando el entorno de desarrollo, utilizaremos un navegador web y la dirección HTTP, IP del controlador, puerto 8080, y el nombre de la página “webvisu.htm".</p>
						<p>Una pantalla de visualización se compone de cuatro sectores:</p>
						<ol>
							<li><strong>Sector superior:</strong> Aquí se podrá escoger el robot sobre el que se desea interactuar. Después también tiene una serie de botones para solicitar la entrada a un modo de trabajo u otro, unos pilotos que nos indican el modo de trabajo activo, las coordenadas cartesianas del robot, el ángulo del eje auxiliar de giro (si es que el robot lo posee) sistema de coordenadas activo y ciclos por minuto de este robot.</li>
							<li>
								<p><strong>Sección izquierda:</strong> Tendremos lo que es la botonera para navegar a través de todos los paneles que incluye la aplicación. El panel por defecto es "Configuración", a través del cual podemos darle valores a una serie de parámetros que nos permitirán configurar el comportamiento general de la aplicación.</p> 
								<p>A través del botón "Automático", entraremos al panel donde se nos mostrará información relativa al modo de trabajo automático, del mismo modo que ocurre con los botones "Aprendizaje" y "Impulsos". </p>
								<p>Con el botón de "Recetas", accederemos a un panel específico general para hacer lo que es la gestión de recetas (cargar, editar, borrar recetas) y también para configurar todos los parámetros de la aplicación a su valor por defecto. </p>
								<p>En el panel de "Alarmas", tendríamos una visión de las 10 alarmas activas en ese momento y un resumen de la situación de cada uno de los robots utilizados.</p>
								<p>Finalmente, tenemos acceso a una serie de paneles específicos que vienen en el template utilizado para construir la plataforma de desarrollo de aplicaciones multi-robot. Estos paneles de visualización se han dejado tal cual, pues pueden ser útiles en caso de que se amplíe la aplicación. Para regresar a los paneles de visualización, iremos a "Vis_Navigation" y daremos "Ir Aplicación".</p>
								<p>Finalmente, podemos escoger el idioma de los paneles de visualización a través de una serie de banderitas: español, inglés y portugués.</p>
							</li>	
							<li><strong>Sector central:</strong> El panel central va cambiando en función del botón que tengamos pulsado en cada momento.</li>
							<li><strong>Sector derecho:</strong> Este sector mostrará la información de los elementos de hardware del controlador, es decir, entradas y salidas digitales, o las entradas de emergencia. En el caso específico de que estemos visualizando el panel de "Automático", veremos además el contenido de los registros de desplazamiento para la cinta de recogida y de entrega.</li>							
						</ol>
					</div>
				</section>
				
				<section class="aspectos-container">
					<h3>Aspectos Clave</h3>
					<p>Para acceder a las pantallas de visualización, puedes hacerlo desde el entorno de desarrollo haciendo doble clic en "Vis_Principal" o mediante un navegador web usando la dirección http://IP_Controlador:8080/webvisu.htm.</p>
					<p>Las pantallas de visualización se dividen en cuatro secciones:
						<ul>
							<li><strong>Superior:</strong> Permite ordenar el modo de trabajo, seleccionar el robot con el que se desea interactuar y monitorear la posición cartesiana del robot activo.</li>
							<li><strong>Lateral izquierdo:</strong> Ofrece opciones para seleccionar la categoría de información que se mostrará en el panel central (como modos de trabajo, alarmas, recetas, etc.).</li>
							<li><strong>Central:</strong> Muestra la información y permite modificar los parámetros relativos a la categoría seleccionada en la sección lateral izquierda.</li>
							<li><strong>Lateral derecho:</strong> Permite visualizar el estado de las entradas/salidas del controlador y el contenido de los registros de desplazamiento de las cintas de recogida y entrega.</li>
						</ul>
					</p>
					<p>Es posible escoger el idioma de las pantallas de visualización entre tres opcione (español, inglés y portugués).</p>
				</section>	
			</article>
			
			<!-- Capítulo 5: Modo Impulsos Básico -->
			<article class="capitulo-container" id="capitulo5" style="display:none;">
				<iframe 
					src="https://www.youtube.com/embed/5EPx4OiCEzk?modestbranding=1&rel=0&enablejsapi=1" 
					frameborder="0"
					loading="lazy"
					allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" 
					allowfullscreen 
					aria-label="Vídeo que describe las opciones básicas disponibles en el panel de modo impulsos"> 
				</iframe>

				<section class="transcripcion-container">
					<div class="transcripcion-header" data-leccion="Lección 5">
						<span class="transcripcion-icon" aria-hidden="true">▶</span>
						<span class="transcripcion-text">Transcripción</span>
					</div>
					<div class="transcripcion-content">
						<p>En este vídeo veremos las posibilidades más básicas del modo de trabajo impulsos. Para ello, tomaremos el robot número 1 y ordenaremos que pase a modo de trabajo impulsos a través del botón de la sección superior de las pantallas de visualización, lo confirmaremos con su piloto correspondiente y, además, a través de la etiqueta que aparece en la zona superior del área de trabajo del robot.</p>
						<p>Luego, para acceder a las opciones más básicas, nos iremos al panel de impulsos, y aquí vemos las operaciones que podemos realizar en este modo de trabajo. Básicamente, son tres: operaciones respecto a lo que son los ejes primitivos, operaciones respecto, cartesianas, respecto al TCP del robot, y en caso de que el robot tenga un eje auxiliar de rotación, pues, el desplazamiento en sentido horario o antihorario de este eje de rotación.</p>
						<p>Para ayudarnos en la explicación, lo que vamos a hacer es apoyarnos en una representación 3D del robot. Bien, vamos a hacer un ejemplo de cada. Por ejemplo, vamos a intentar desplazar en modo impulsos el eje primitivo del robot, el eje A. Si vamos para adentro, vemos que efectivamente el brazo A se mueve hacia adentro y solo lo hace el eje A, sin importar lo que esté haciendo el TCP del robot.</p>
						<p>Vale, podemos hacer lo mismo con el eje B y el eje Z, o eje C, perdón. Vale, otra cosa que podemos hacer es desplazar cartesianamente, esta vez, el TCP del robot (el punto central de la herramienta, el TCP). Por ejemplo, en X, vemos que vamos en positivo o en negativo, y para realizar este movimiento se mueven los tres brazos.</p>
						<p>Y también, por supuesto, podemos mover el eje de rotación. En este caso, el robot tiene un eje de rotación, pues le podemos dar en un sentido, antihorario, y luego en el otro sentido.</p>
						<p>Vale, ¿qué más cosas podemos hacer? Podemos variar los parámetros del movimiento. Por ejemplo, en este caso, cuando estamos moviendo en X, puede ser que nos parece que va muy lento, pues simplemente tenemos que coger aquí, en esta sección del panel de impulsos, seleccionar que vamos a modificar un parámetro cartesiano y que va a ser el X. En este caso, la velocidad es 20, y queremos que vaya pues al doble de velocidad. Le damos así y ya se observa que la velocidad es mayor.</p>
						<p>Otra cosa que podemos hacer es mover una distancia máxima. Por ejemplo, en este caso vemos que el robot está en la cota Z 235,7. Queremos bajar esta cota 7 décimas y esto, haciéndolo de esta forma, es bastante complicado porque enseguida nos vamos a pasar pero, si venimos aquí, cartesiano, Z y le decimos 0,7 y ahora cogemos y vamos en negativo vemos que, da igual la velocidad que estemos utilizando, que lo máximo que se va a mover es esa distancia. Si ahora quisiéramos bajar 5 mm, por ejemplo, haríamos la misma operación. Esta es una forma bastante fiable de llevar el robot a un punto que nosotros deseemos.</p>
						<p>Pasa lo mismo con el resto de movimientos. Por ejemplo, un  primitivo, seleccionaríamos "Robot Axes", seleccionamos el primitivo que vamos a mover (en este caso, por ejemplo, el A) y variaríamos la velocidad. En este caso iba muy rápido pues le ponemos una velocidad más lenta. A ver, más lenta aún y ya vemos que el robot cada vez va más lento, mucho más lento aún, y esto nos permite desplazar, probar cada uno de los ejes de forma independiente (muy útil durante la puesta en marcha), o ir a una posición muy concreta para comprobar que estamos justo encima, o para, bueno, hacer opciones de calibrado de la cámara de visión artificial, etcétera.</p>
						<p>Y esto es todo.</p>	
					</div>
				</section>
				
				<section class="aspectos-container">
					<h3>Aspectos Clave</h3>
					<p><strong>Activación:</strong> Dirígete al menú superior y selecciona el robot con el que deseas trabajar en modo impulsos. Luego, pulsa el botón de cambio a modo impulsos. Sabrás que el robot ha recibido la orden cuando el botón de cambio de modo se ilumine en verde. Para confirmar que el robot está efectivamente en modo impulsos, verifica el piloto a la izquierda del botón y/o la etiqueta ubicada en la parte superior de la representación del área de trabajo del robot en el panel automático. A continuación nos dirigiremos al panel de modo impulsos pulsando el botón correspondiente en el menú lateral izquierdo.</p>						
					<p><strong>Operaciones:</strong> Una vez en el panel de impulsos, al que se accede a través del botón correspondiente de la sección lateral izquierda, se pueden realizar tres tipos de operaciones básicas: desplazamientos de los ejes primitivos del robot, desplazamientos cartesianos del TCP (punto central de la herramienta), y rotación del eje auxiliar si el robot está equipado con uno.</p>
					<p><strong>Parámetros:</strong> El panel de impulsos también ofrece la posibilidad de ajustar parámetros como la velocidad y la distancia de movimiento. Por ejemplo, se puede incrementar la velocidad de desplazamiento en el eje X o limitar el movimiento en impulsos a una distancia máxima. Esto resulta particularmente útil para hacer ajustes precisos y para realizar pruebas que requieren un control exacto del movimiento del robot.</p>
					<p><strong>Utilidad:</strong> El modo impulsos es especialmente útil durante la puesta en marcha del robot, ya que permite identificar ejes, comprobar los sentidos de movimiento y calibrar el centro de coordenadas del robot en relación con el centro de coordenadas de las cintas y/o cámaras de visión artificial.</p>
				</section>	
			</article>

			<!-- Capítulo 6: Modo Impulsos Avanzado -->
			<article class="capitulo-container" id="capitulo6" style="display:none;">
				<iframe 
					src="https://www.youtube.com/embed/k7e_zOWrzlQ?modestbranding=1&rel=0&enablejsapi=1"  
					frameborder="0" 
					loading="lazy"
					allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" 
					allowfullscreen 
					aria-label="Vídeo que describe las opciones avanzadas disponibles en el panel de modo impulsos"> 
				</iframe>

				<section class="transcripcion-container">
					<div class="transcripcion-header" data-leccion="Lección 6">
						<span class="transcripcion-icon" aria-hidden="true">▶</span>
						<span class="transcripcion-text">Transcripción</span>
					</div>
					<div class="transcripcion-content">
						<p>En este vídeo veremos las opciones avanzadas del modo de trabajo impulsos. Para ello cogeremos el robot número 1, lo pasaremos a modo de trabajo impulsos, confirmaremos que este modo de trabajo ha sido aceptado a través del piloto correspondiente y también a través de la etiqueta que figura en la zona superior del área de trabajo, que el robot número 1 se encuentra, efectivamente, en modo impulsos.</p>
						<p>Ahora, nos dirigiremos al panel de aprendizaje, que es un panel un tanto especial porque reúne funciones propias del modo impulsos, pero también propias del modo aprendizaje, y nos fijaremos en las que se incluyen en el cuadro este de aquí, que son opciones relativas a segmentos que conforman una trayectoria. Existen otros botones activos, pero se refieren más a las operaciones básicas que ya hemos visto en un vídeo anterior.</p>
						<p>Bien, en cuanto a las operaciones referidas a la trayectoria, hay que decir, o recordar, que una trayectoria se compone de una serie de segmentos. En este caso, en modo impulsos, todos los segmentos que vamos a utilizar son lineales. Es cierto que tenemos segmentos tipo circular y tipo spline, pero en modo impulsos únicamente trabajaremos con segmentos lineales. Y, para fabricar una trayectoria, lo que hemos de hacer es concatenar una serie de segmentos predefinidos hacia unas cotas determinadas.</p>
						<p>En este caso, vamos a crear una trayectoria muy simple, consistente en dos segmentos: uno que vaya desde la posición actual al punto 3, y otro que vaya desde el punto 3 al punto 2. Para ello, simplemente venimos aquí, pulsamos "ir punto 3" e "ir punto 2", y si nos fijamos en los movimientos disponibles, antes teníamos 20 movimientos lineales disponibles y ahora tenemos solamente 18. ¿Por qué? Porque hemos introducido estos dos.</p>
						<p>Muy bien, también tenemos otra serie de información interesante, que es, la trayectoria que acabamos de crear, aquí nos dice la longitud de la trayectoria, la longitud total de la trayectoria compuesta de dos segmentos, y la longitud del siguiente segmento, es decir, este de aquí, el que va de la posición actual al punto 3.</p>
						<p>Otros datos interesantes que nos pueden ser de utilidad es el tiempo restante a la velocidad actual, que serían 100 unidades por segundo. Cuando yo pulse "ir" o "desplazarse" de esta trayectoria, veremos el tiempo que nos falta hasta llegar al final.</p>
						<p>Bien, vamos a poner a prueba la teoría que es dándole al botoncito de trayectoria positiva nos moveremos en sentido positivo. Ya hemos llegado. Si nos hemos fijado en los valores actuales, veremos que efectivamente el tiempo va disminuyendo a la vez que la posición, etcétera.</p>
						<p>Vamos a darle otra vez. Estos elementos de aquí, los valores actuales, son muy importantes cuando vayamos en modo automático para controlar en qué posición de la trayectoria nos encontramos, cuánto tiempo falta para finalizar la trayectoria, etcétera. Y esto nos permitirá pués activar electroválvulas cuando falte un cierto tiempo o realizar operaciones cuando estemos a cierta distancia del objetivo.</p>
						<p>Muy bien, lo visto hasta ahora, si nos hemos fijado bien, vemos que el robot no pasa por el punto 3 realmente, sino que hace como una especie de redondeo cuando entra en esta área de color rojo y continúa por ahí. ¿Esto por qué es? Esto es porque el primer segmento al que se dirigía desde el punto 7 hasta el punto 3, este de aquí, tenía definido un parámetro que se llama zona, con un valor de 50, es decir, tiene un radio de 50. Con lo cual, el robot, en lugar de llegar al punto 3, lo que hace es una suavización, coge estos dos segmentos y los conecta de forma suave.</p>
						<p>¿Qué es lo que hace el robot? Aunque aquí veamos un círculo, en realidad esto en el espacio tridimensional es una esfera. Lo que hace el robot es que, cuando alcanza la superficie de esta esfera, la superficie teórica que sería la línea recta esta de aquí y esta de aquí, lo que hace es entrar tangencialmente y salir tangencialmente, que es básicamente la definición de un spline. El sistema lo que hace es hacer un movimiento tipo spline por el interior de la esfera y nunca alcanza el punto 3. De esta forma, hace lo que se llama un "connection path": conecta el path del primer segmento con el path del siguiente segmento y crea un único segmento más largo. Volvemos otra vez hacia el origen.</p>
						<p>Bien, dicho esto, vamos a añadir un nuevo grado de dificultad, que sería realizar un movimiento con el eje auxiliar de rotación insertado o superpuesto a la trayectoria que tenemos de momento almacenada en el buffer de movimientos. ¿Cómo hacemos esto? Pues lo vamos a hacer a través del "giro recogida", este botoncito de aquí. Si vamos a buscar aquí los parámetros, vemos que el giro va a tener 90 grados, que se va a iniciar en el segmento 1210, que sería este de aquí, vemos que cada segmento tiene un identificador único, y va a finalizar en el segmento 1215 que sería el segundo que hemos añadido.</p>
						<p>¿Cuándo va a iniciar? Pues cuando lleve transcurrido 0.5 mm del segmento 1210. ¿Y cuándo lo va a finalizar? Cuando le falten 0.5, de ahí el signo negativo, cuando le falten 0.5 mm para finalizar el segmento 1215.</p>
						<p>Bien, visto esto, le damos al botón y volvemos a repetir el movimiento. Vemos aquí, en la posición de giro, como realmente está girando, y también en el gráfico, lo único que en el gráfico no se ve tan bien. Da la impresión de que ya ha finalizado el ángulo de -90, pero en realidad aún le falta un pelín porque hasta que no le queden 0.5 mm realmente no acaba. Vale, ahí está. Es decir, lo que vamos a hacer es un movimiento síncrono con la trayectoria del robot y entre dos puntos que a nosotros nos interese.</p>
						<p>Finalmente, vamos a hacer otra operación, que es vamos a borrar totalmente la trayectoria del buffer de movimientos. Esto lo haremos a través de esta casilla e indicando que queremos borrar desde el segmento cero. El segmento cero no existe, aquí vemos que no hay ningún segmento cero, pero es un código especial que lo que hace es borrar todos los segmentos del buffer de movimientos. De momento tenemos dos. Vemos aquí que tenemos disponibles 18 de los 20 que teníamos. Le damos aquí y ya volvemos a tener 20, y además no podemos desplazarnos a través de la trayectoria porque no hay trayectoria.</p>
						<p>Bien, repitamos la operación que hemos hecho hasta ahora, pero vamos a quitarle la zona al punto 3. Venimos al punto 3, sus coordenadas cartesianas, y en lugar de 50, vamos a decirle que no, que queremos cero, y vamos a volver a crear una trayectoria idéntica a la anterior. Es decir, vamos al punto 3 y vamos al punto 2, y como ya tenemos trayectoria creada, pues los botones de movimiento por impulsos se han activado de nuevo. Vamos a ver qué pasa. Le damos y vemos que efectivamente llega a la posición 3, pero no continúa como antes sucedía. Se queda ahí parado. ¿Por qué? Porque él considera que esta trayectoria, que está compuesta de dos segmentos, es una trayectoria porque los dos segmentos se encuentran en memoria. Deseamos realmente pararnos, no tiene zona, no hay suavización, por tanto él lo que hace es pararse aquí.</p>
						<p>Podemos ir hacia atrás. Hacia delante. igual que antes, pero esta trayectoria finaliza ahí. Si queremos saltar al siguiente segmento que se encuentra en memoria, hemos de decirle siguiente "connection path". Le damos y ahora ya podemos movernos a través del siguiente segmento, pero no podemos regresar al anterior. El anterior ya se ha cumplido, hemos saltado y hemos salido de este segmento. Y en principio estos son todos los movimientos avanzados que posee el modo impulsos.</p>						</div>
				</section>
				
				<section class="aspectos-container">
					<h3>Aspectos Clave</h3>
					<p><strong>Activación:</strong> Dirígete al menú superior y selecciona el robot con el que deseas trabajar en modo impulsos. Luego, pulsa el botón de cambio a modo impulsos. Sabrás que el robot ha recibido la orden cuando el botón de cambio de modo se ilumine en verde. Para confirmar que el robot está efectivamente en modo impulsos, verifica el piloto a la izquierda del botón y/o la etiqueta ubicada en la parte superior de la representación del área de trabajo del robot en el panel automático. A continuación nos dirigiremos al panel de modo aprendizaje (si, aprendizaje) pulsando el botón correspondiente en el menú lateral izquierdo.</p>						
					<p><strong>Creación de trayectorias:</strong> Una de las operaciones más destacadas es la creación de trayectorias mediante la concatenación de segmentos lineales. Para ello, deberás pulsar, en el orden deseado, el botón que ordena dirigir al robot hacia un punto clave previamente definido en el casillero correspondiente. Cada pulsación generará un segmento que se almacenará en un buffer o registro de movimientos, aunque esto no hará que el robot se desplace aun. Una vez finalizada la creación de la trayectoria, podrás desplazarte a lo largo de ella en uno u otro sentido en modo impulsos (mientras se pulsa el botón correspondiente). Durante el movimiento, podrás comprobar la longitud total de la trayectoria y el tiempo estimado para completarla.</p>
					<p><strong>Optimización de trayectorias:</strong> Al definir trayectorias, el robot puede aplicar una suavización entre segmentos usando el parámetro "Zona". Esto evita transiciones bruscas y permite un movimiento más fluido. Además, es posible incorporar movimientos del eje auxiliar de rotación dentro de la trayectoria, sincronizándolos con el movimiento del robot.</p>
					<p><strong>Ajuste de trayectorias:</strong> Es posible eliminar trayectorias del buffer de movimientos utilizando comandos específicos, como borrar desde el segmento cero. También se pueden ajustar trayectorias existentes, por ejemplo, eliminando zonas de suavización para que el robot se detenga en puntos específicos.</p>
				</section>	
			</article>	

			<!-- Capítulo 7: Modo Aprendizaje -->
			<article class="capitulo-container" id="capitulo7" style="display:none;">
				<iframe 
					src="https://www.youtube.com/embed/95tx77AlOYk?modestbranding=1&rel=0&enablejsapi=1"
					frameborder="0"
					loading="lazy"
					allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" 
					allowfullscreen 
					aria-label="Vídeo que describe las opciones disponibles en el panel de modo aprendizaje"> 
				</iframe>

				<section class="transcripcion-container">
					<div class="transcripcion-header" data-leccion="Lección 7">
						<span class="transcripcion-icon" aria-hidden="true">▶</span>
						<span class="transcripcion-text">Transcripción</span>
					</div>
					<div class="transcripcion-content">
						<p>En este vídeo veremos las funcionalidades que incluye el modo de trabajo aprendizaje. Para ello, lo primero será seleccionar el robot con el cual queremos trabajar. En este caso, será el robot número 1 y le ordenaremos pasar a modo aprendizaje.</p>
						<p>Confirmaremos que el modo aprendizaje ha sido aceptado con el piloto correspondiente y nos dirigiremos al panel de aprendizaje. Bien, desde este panel podemos hacer básicamente dos cosas.</p>
						<p>Primero, comprobar que el robot se dirige correctamente a todos los puntos que hemos encontrado previamente gracias al uso del modo impulsos y que se encuentran definidos en esta sección. En esta sección podemos ver las coordenadas y zona para cada uno de los puntos que conformarán nuestra trayectoria del modo automático.</p>
						<p>En este caso, una vez ya encontrados, repito, utilizando el modo de trabajo impulsos, podemos comprobar si el robot se dirige a cada uno de ellos de forma individual a las velocidades que emplearemos cuando nos encontremos en el modo automático de trabajo.</p>
						<p>Por ejemplo, pulsando aquí podemos ver cómo se dirige a este punto. El siguiente punto de la trayectoria automática sería ir a la posición de espera de ítem, el siguiente a la de recogida del ítem, luego nos retiraríamos hasta la posición segura superior de recogida, luego iríamos a reposo, a entrega, a espera de entrega y finalmente a entrega. Luego, nos retiraríamos a la superior de entrega, volveríamos a la de recogida, a la superior de recogida, y así.</p>
						<p>Esto lo podemos comprobar también utilizando la Smartvisu. Venimos aquí, vamos a minimizar esto y así trabajaremos con los dos elementos. Podemos ver cómo el robot va dirigiendo cada uno de los, va dirigiéndose a cada uno de los puntos que tenemos pregrabados y si realmente lo hace correctamente, si las pinzas del robot se sitúan encima del ítem de forma correcta para cogerlo, etcétera.</p>
						<p>Esta es la parte quizás menos interesante. La más interesante, yo creo que es esta de aquí abajo, que es todos estos puntos secuenciarlos de una forma automática, es decir, crear una trayectoria secuenciada que se va repitiendo una y otra vez y nos permite comprobar si la cadencia de la máquina va a alcanzar las expectativas que posee el cliente para esta aplicación.</p>
						<p>Vamos a activarla. Cogemos aquí "Activar secuencia". Vemos que el robot se dirige a la posición de reposo y luego, ya, inmediatamente, con las velocidades que hemos definido en estas cajetillas, se dirigirá a cada uno de los puntos. En este caso, se ha ido al de espera producto (espera de picking). </p>
						<p>Vamos a decirle que ya ha llegado un producto, decimos OK, y ahora ha alcanzado el punto 5, que sería "Espera Entrega" que está, pues, para simular que está esperando la llegada de una caja. Vamos a decirle que la caja ya está disponible. En estos casos, como los permisivos para continuar permanecen activos, ya no hay ninguna espera, simplemente el ciclo se va repitiendo una y otra vez sin parar. Y en esta parte superior vemos los ciclos por minuto que estamos alcanzando con los parámetros actuales y los puntos definidos en las posiciones en las que están definidas.</p>
						<p>Bien, como todo ciclo se compone de un viaje de picking en el que no tiene... el el robot no contiene aún ningún producto, y otro de placing en el que viaja con un producto cogido, podemos definir velocidades distintas para cada uno de los sentidos. Por ejemplo, el de recogida, que no tiene nada en las pinzas, podría llegar a hacerlo más rápido. Entonces podemos coger y modificar la velocidad aumentándosela a 5000 y ya vemos que el viaje de recogida lo hace mucho más rápido. La cadencia nos ha aumentado un poco.</p>
						<p>También puede ser que nos digan que la operación de picking, es decir, si queremos coger un producto con una ventosa ¿no?, lo que es el tiempo para que la ventosa haga vacío encima del producto, pues, en lugar de 1 segundo, pues, quizás nos digan que sean 200 milisegundos. Pues le añadimos el tiempo que nos digan y ya vemos que aquí ya ha vuelto a aumentar.</p>
						<p>Y para dejar el producto, para soltarlo, pues quizás porque el producto sea muy pesado o lo que sea, no haga falta 200 milisegundos. Con 100 milisegundos es suficiente, porque al cortar la orden de vacío la propia gravedad hará que el producto, nos ayudará a que el producto, caiga más rápido.</p>
						<p>Bien, y aquí ya vemos que el ciclo poco a poco va aumentando su cadencia. Puede pasar también de que, aunque la velocidad de entrega no sea tan rápida como la de recogida, porque el robot está transportando un producto, no hace falta que sea tan baja. Podemos, a lo mejor, subirla un pelín.</p>
						<p>Esto lo podemos probar incluso con un producto para ver cómo se comporta. Hay que tener en cuenta aquí que el simulador no simula las inercias del producto ni la masa de la herramienta, pero sí nos permite acercarnos bastante a la realidad.</p>
						<p>Entonces, con estos parámetros, más o menos podemos ver qué cadencia aumentará. Por ejemplo, otros parámetros que tenemos disponibles son estos de aquí, las rampas que podemos hacerlas más bruscas o menos bruscas. La velocidad es muy importante porque aquí no vemos las inercias. El producto, si es muy grande, estas aceleraciones tan bruscas y estos frenazos tan bruscos pueden ser que… que el robot sea capaz de hacerlo no signifique que sea bueno para la aplicación: una aceleración muy brusca puede desprender el producto de las pinzas.</p>
						<p>Vamos a jugar, por ejemplo, con las rampas, con la suavidad de las rampas. Vamos a hacerlas menos suaves, o sea, más bruscas. Y aquí vemos que sí ha mejorado un pelín lo que son los ciclos por minuto, pero tampoco espectacularmente mucho: hemos subido de 53 a 56. Vamos a volver a aumentar la suavidad. Es decir, que igual no merece mucho la pena, para ganar tres golpes por minuto, empeorar la suavidad de las rampas porque eso puede hacer que el producto no se comporte correctamente en la herramienta.</p>
						<p>En definitiva, todos estos parámetros nos van sirviendo, junto con la Smartvisu, para determinar, antes incluso de tener el robot disponible, y esto va muy bien cuando se le hacen presentaciones a los clientes o en formaciones académicas, si el robot puede alcanzar, o puede aproximarse al menos a las prestaciones que el cliente nos pide, a las deseadas, o si estamos por el contrario muy lejos y ya no merece la pena insistir. Si estamos muy cerca siempre se podrían mejorar, pues, los tiempos de operación ¿no? Se podrían hacer más rápidos o menos indicándole al cliente, pues, que modifique, pues, el sistema, pues, neumático o modifique la herramienta para que pese menos u otras operaciones en la máquina. Pero esto es una herramienta bastante potente porque, sin inversión ni de tiempo ni económica, nos permite hacernos una idea muy rápida de si el robot va a alcanzar lo que se le está exigiendo.</p>																
					</div>
				</section>
				
				<section class="aspectos-container">
					<h3>Aspectos Clave</h3>
					<p><strong>Activación:</strong> Dirígete al menú superior y selecciona el robot con el que deseas trabajar en modo aprendizaje. Luego, pulsa el botón de cambio a modo aprendizaje. Sabrás que el robot ha recibido la orden cuando el botón de cambio de modo se ilumine en verde. Para confirmar que el robot está efectivamente en modo aprendizaje, verifica el piloto a la izquierda del botón y/o la etiqueta ubicada en la parte superior de la representación del área de trabajo del robot en el panel automático. A continuación nos dirigiremos al panel de modo aprendizaje pulsando el botón correspondiente en el menú lateral izquierdo.</p>						
					<p><strong>Creación de trayectorias:</strong> Este modo es similar al modo impulsos en el sentido de que tambien permite construir una trayectoria mediante la concatenación de segmentos lineales dirigidos hacia puntos clave, los cuales puedes configurar en el casillero correspondiente. La principal diferencia es que, en el modo aprendizaje, los movimientos almacenados en el buffer de movimientos se ejecutan de inmediato, mientras que en el modo impulsos es necesaria una orden de jogging positivo o negativo adicional para desplazar el TCP del robot a lo largo de la trayectoria creada.</p>
					<p><strong>Simulación de ciclos:</strong> Esta función permite ejecutar una trayectoria en un ciclo continuo de ida y vuelta, incluyendo tiempos de espera en las posiciones de recogida y/o entrega del producto para simular el tiempo de actuación del gripper. La simulación del ciclo de trabajo del robot facilita el análisis del movimiento a lo largo de la trayectoria y permite ajustar diversos parámetros para optimizar la cadencia del ciclo y evaluar qué tan cerca o lejos estamos de cumplir con las expectativas de producción deseadas.</p>
					<p><strong>Utilidad:</strong> El modo Aprendizaje es esencial tanto durante la fase de calificación de la máquina, para determinar si cumple con los requisitos del cliente, como durante la puesta en marcha. Permite comprobar el comportamiento del robot con producto real antes de implementar completamente el modo automático (que incluye otras tareas como la calibración de cintas, cámaras de visión, etc.). Durante las pruebas con producto real, es posible ajustar la suavidad de las rampas y adaptar las velocidades para compensar efectos que no pueden simularse, como vibraciones o pérdida de producto debido a aceleraciones bruscas, y verificar si el sistema sigue cumpliendo con las especificaciones del cliente.</p>
				</section>	
			</article>				
			
			<!-- Capítulo 8: Modo Limpieza -->
			<article class="capitulo-container" id="capitulo8" style="display:none;">
				<iframe 
					src="https://www.youtube.com/embed/yeJFuh62yWI?modestbranding=1&rel=0&enablejsapi=1" 
					frameborder="0"
					loading="lazy"
					allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" 
					allowfullscreen 
					aria-label="Vídeo que describe las opciones disponibles en el panel de modo limpieza"> 
				</iframe>

				<section class="transcripcion-container">
					<div class="transcripcion-header" data-leccion="Lección 8">
						<span class="transcripcion-icon" aria-hidden="true">▶</span>
						<span class="transcripcion-text">Transcripción</span>
					</div>
					<div class="transcripcion-content">
						<p>En este vídeo veremos la funcionalidad del modo de trabajo limpieza. Este modo de trabajo ha sido diseñado para desplazar el robot hacia una zona predefinida, más allá de la zona de trabajo habitual del robot, para operaciones de limpieza o de mantenimiento de, por ejemplo, de las pinzas del robot o de la herramienta que porte este robot.</p>
						<p>Dado que estas coordenadas pueden encontrarse más allá de los límites software definidos para este robot, la maniobra se realizará a una velocidad inferior, una velocidad segura que suele ser bastante más baja que la de trabajo habitual, y siempre por el camino seguro, es decir, antes de desplazarse por las coordenadas XY, siempre se elevará la cota Z hasta una altura de seguridad, altura en la que puede navegar el robot de una forma segura y, una vez ha alcanzado esa cota de navegación, se procederá a desplazar el robot a las cotas XY finales, las que hayamos definido para la posición de limpieza. Una vez alcanzadas las cotas XY, entonces se bajará la Z a la definida para la posición de limpieza.</p>						
						<p>Estas coordenadas se parametrizan en el panel de aprendizaje dentro de este indicador donde pone “Posiciones” para la posición de limpieza. En este caso, tenemos definidas unas coordenadas X0, Y-500, que está más allá del límite inferior software para la Y, y una cota Z de 125.</p>
						<p>Si activamos el modo limpieza, vemos que primero se desplaza en XY y luego la Z. Esta sería la posición de limpieza. Esta posición, que es Y-500, se encuentra fuera de la zona de seguridad definida. Esto lo podemos comprobar aquí: el límite negativo para la Y, para este robot, sería -400 y, sin embargo, está en -500, sin generar ningún aviso ni ninguna alarma.</p>						
						<p>Si ahora saliéramos de la zona de limpieza y entrásemos, por ejemplo, en modo impulsos, veríamos que ya nos está dando un aviso. Vamos a ver el aviso, que es: nos está indicando que el robot se encuentra más allá del límite cartesiano Y en negativo, en sentido negativo.</p>
						<p>Como el modo impulsos permite sacar el robot de una zona peligrosa, simplemente no deja de ser un aviso. Salimos de impulsos, reseteamos el aviso, y ahora vamos a entrar en un modo de trabajo, que es el aprendizaje.</p>						
						<p>En este caso, el robot sí se encuentra fuera de la zona de seguridad y sí se genera un fallo. Si volvemos al panel de alarmas, vemos realmente que hay un fallo. Reseteamos, y si en esta posición, fuera de la zona de trabajo, entramos en modo automático, el modo automático sí lo tiene en cuenta. Regresa primero por el camino seguro, es decir, elevando la Z y luego desplazándose en XY a reposo, y entra tranquilamente en el modo de trabajo automático.</p>					
					</div>
				</section>				
				
				<section class="aspectos-container">
					<h3>Aspectos Clave</h3>
					<p><strong>Activación:</strong> Dirígete al menú superior y selecciona el robot con el que deseas trabajar en modo limpieza. Luego, pulsa el botón de cambio a modo limpieza. Sabrás que el robot ha recibido la orden cuando el botón de cambio de modo se ilumine en verde. Para confirmar que el robot está efectivamente en modo limpieza, verifica el piloto a la izquierda del botón y/o la etiqueta ubicada en la parte superior de la representación del área de trabajo del robot en el panel automático. No existe un panel especifico para este modo de trabajo.</p>											
					<p><strong>Funcionalidad:</strong> Este modo está diseñado para mover el robot a unas coordenadas XYZ específicas, generalmente fuera del área de trabajo habitual en modo automático, con el fin de realizar tareas de limpieza o mantenimiento en la pinza. Dado que las coordenadas de la posición de limpieza pueden estar más allá de los límites software configurados, el robot se desplazará a una velocidad reducida siguiendo un camino seguro. Esto implica elevar primero la coordenada Z hasta una altura considerada segura y libre de obstáculos, luego moverse en el plano XY hasta alcanzar las coordenadas de la posición de limpieza, y finalmente ajustar la coordenada Z para llegar a la altura final de la posición de limpieza.</p>
					<p><strong>Retorno seguro:</strong> Si el robot se encuentra fuera de los límites software configurados y se ordena cambiar a ciertos modos de trabajo, como el de aprendizaje, se generará un fallo porque el modo aprendizaje no permite operar fuera de los limites software configurados. Sin embargo, al cambiar al modo automático, el robot regresará por un camino seguro hasta su posición de reposo antes de reanudar su operación normal, asegurando así la seguridad del proceso.</p>					
				</section>	
			</article>	
				
			<!-- Capítulo 9: Visualización 3D -->
			<article class="capitulo-container" id="capitulo9" style="display:none;">
				<iframe 
					src="https://www.youtube.com/embed/zqw2l6VHdgs?rel=0&enablejsapi=1" 
					frameborder="0"
					loading="lazy"
					allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" 
					allowfullscreen 
					aria-label="Vídeo que describe las posibilidades del visualizador 3D utilizado conjuntamente con la aplicación."> 
				</iframe>

				<section class="transcripcion-container">
					<div class="transcripcion-header" data-leccion="Lección 9">
						<span class="transcripcion-icon" aria-hidden="true">▶</span>
						<span class="transcripcion-text">Transcripción</span>
					</div>
					<div class="transcripcion-content">
						<p>En este vídeo veremos cómo podemos representar en tres dimensiones el comportamiento de una máquina creada con la plataforma de desarrollo de aplicaciones multirrobot. Para ello, se hace uso de un aplicativo externo, llamado Smartvisu, que se basa en Unity3D y que no necesita ser instalado; es autoejecutable.</p>
						<p>La plataforma de desarrollo de aplicaciones multirrobot, en su panel de configuración, incluye un botón que se llama "Visualización 3D" que, una vez activado, enviará a dicho programa externo, mediante comunicaciones Ethernet UDP, toda una serie de datos que permitirán crear en 3D la configuración actual de la máquina.</p>
						<p>Para ello, vamos a ver el aspecto de este programa externo, que se llama Smartvisu. Vemos que en su pantalla de presentación solo necesita un dato que es la IP del controlador. Este aplicativo externo, de momento, solo es compatible con una serie reducida de robots, todos de Schneider Electric y, básicamente, son los robots tipo Scara, los tipo Delta de la serie T, que solo tienen dos brazos, y los tipo Delta de la serie P, que son los que tienen tres brazos y además son los incluidos en la plataforma de desarrollo de aplicaciones multirrobot.</p>
						<p>Además, es posible utilizar una serie de objetos geométricos para, por ejemplo, representar ítems o cajas u otros elementos, y también cintas. Bien, le damos a conectar y vemos que enseguida nos aparece el estado actual de configuración de nuestra máquina, tal como hayamos definido en la plataforma de desarrollo de aplicaciones multirrobot.</p>
						<p>Por supuesto, podemos con el ratón hacer zoom, quitarlo, rotarlo, verlo en todos los ángulos. Además, aquí tenemos un atajo en tres dimensiones para poder verlo desde distintos puntos de vista, aunque con el ratón es mucho más cómodo y luego, si pulsamos y mantenemos pulsado el botón CTRL y hacemos clic sobre cada uno de los robots, nos aparecerá información adicional de cada uno de ellos. Vamos a apartarlo un poco.</p>
						<p>Bien ¿Qué información adicional? Pues básicamente, la referencia del robot, si tiene o no tiene eje de giro (todos ellos lo tienen de momento), y las coordenadas cartesianas de su TCP (del centro de coordenadas de la herramienta).</p>
						<p>También podemos optar por ver el espacio de trabajo de cada uno de los robots o, vamos a configurar el segundo, o la trayectoria seguida por el TCP (por el centro de coordenadas de la herramienta). Vamos a hacerlo un poquito más grande.</p>
						<p>Bien, si volvemos a la aplicación y cogemos los dos robots que vamos a utilizar para esta demostración y los habilitamos para funcionar, vamos a darle marcha a las cintas. Si volvemos a la pantalla 3D, al programa externo, aquí vemos, vamos a quitar esto que está molestando más que ayudar, aquí vemos el funcionamiento de la visualización 3D, que como vemos está siguiendo perfectamente lo que está haciendo la máquina.</p>
						<p>Aquí, si nos fijamos, vemos la trayectoria marcada para el robot número 2; el 1 también se la podemos marcar. Ahí se ve. Esto es una herramienta muy potente, sobre todo en las fases de desarrollo de la aplicación, cuando aún no tenemos disponible un robot físicamente o, aun teniéndolo, no nos interesa probar con el robot para evitar impactos o porque no estamos seguros de si algún algoritmo está bien depurado o puede ser un riesgo probarlo con el robot físicamente.</p>
						<p>En tales casos, siempre se recomienda trabajar con los ejes en modo virtual y utilizar esta herramienta porque nos da una flexibilidad bastante elevada, incluso en la selección de algunos de los parámetros pues, por ejemplo, para ver si el reparto de cargas es correcto o si va a dar de sí. Unida con el simulador de ítems, esta herramienta puede ayudarnos a ver si la máquina, cuando conectemos este programa en la máquina real, va a ser correcto o no.</p>
						<p>La última cosa que hay que decir es que, una vez activado este botón, el botón de visualización, ya no pueden existir más cambios. Ya, lo que es el mundo 3D ya ha sido creado, ya ha sido definido y no puede ser redefinido. Es decir, si queremos utilizar ítems con unas dimensiones distintas, ya no lo podríamos hacer. Tendríamos que apagar el controlador y volverlo a encender. Entonces sí que, al volver a activar el botón "Visualización 3D", estos cambios quedarían reflejados.</p>
						<p>Por ejemplo, si vamos aquí a ítems y hacemos aquí el ítem más grande, esto, este cambio que hemos hecho y que debería haberse reflejado en las características o dimensiones del objeto gráfico en 3D, vemos que no hay cambio alguno porque ya se han mandado estos datos al inicio.</p>
					</div>
				</section>
				
				<section class="aspectos-container">
					<h3>Aspectos Clave</h3>
					<p><strong>Activación:</strong> Dirígete al panel de configuración haciendo clic en el botón correspondiente en el menú lateral izquierdo. Luego, pulsa el botón "Visualización 3D" para activar las comunicaciones EthernetUDP. A continuación, abre la aplicación SmartVisu, introduce la IP del controlador y haz clic en el botón "Connect".</p>
					<p><strong>Funcionalidades:</strong> Smartvisu es una aplicación externa autoejecutable que utiliza un motor Unity3D para representar en un entorno 3D la configuración actual de la línea robótica y mostrar a tiempo real la posición de los robots, de los productos y de los puntos de entrega (cajas, cangilones...). Es compatible con varias gamas de robots de Schneider Electric como las DeltaP o DeltaT e incluye algunas funcionalidades como el ajuste de la vista en 3D, realizar zoom, y obtener información adicional de los robots, como su referencia, su espacio de trabajo o la visualización del rastro que deja el TCP del robot al desplazarse.</p>
					<p><strong>Uso:</strong> La visualización 3D es especialmente útil durante las fases de calificación y desarrollo, ya que permite verificar visualmente las trayectorias y el funcionamiento de los robots con un flujo de productos determinado, sin necesidad de tener la máquina física disponible. Esto facilita la identificación de problemas, la validación de algoritmos y la evaluación de posibles cambios de estrategia en un entorno virtual, antes de realizar el pedido de material, lo cual puede resultar inestimable pues permite ahorrar tiempo y reducir costes.</p>
					<p><strong>Limitaciones:</strong> Una vez activada la visualización 3D, no es posible modificar los datos físicos de los elementos representados hasta reiniciar el controlador. Los cambios en las dimensiones o características de los ítems no se actualizarán en la visualización 3D sin reiniciar el sistema. Por lo tanto, es crucial planificar y verificar los datos antes de activar la visualización.</p>
				</section>	
			</article>			
			
			<!-- Capítulo 10: Simulador de ítems -->
			<article class="capitulo-container" id="capitulo10" style="display:none;">
				<iframe 
					src="https://www.youtube.com/embed/IGlXcWXshPI?modestbranding=1&rel=0&enablejsapi=1"
					frameborder="0"
					loading="lazy"
					allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" 
					allowfullscreen 
					aria-label="Vídeo que describe el apartado de simulación de ítems incluido en la aplicación"> 
				</iframe>
			
				<section class="transcripcion-container">
					<div class="transcripcion-header" data-leccion="Lección 10">
						<span class="transcripcion-icon" aria-hidden="true">▶</span>
						<span class="transcripcion-text">Transcripción</span>
					</div>
					<div class="transcripcion-content">
						<p>En este vídeo se describirá el simulador de ítems integrado en la plataforma. Para conocer sus opciones nos dirigiremos al panel de configuración y a la sección donde se encuentran los parámetros relativos a la captura y simulación de ítems.</p>
						<p>Los primeros parámetros a tener en cuenta corresponden con las dimensiones del propio ítem, que pueden ser distintas según pertenezca a la cinta de recogida o a la de entrega, y el número de ítems a generar en cada disparo. También es importante el modo de trabajo del propio simulador que puede ser continuo, esto es, que el disparo se produzca de forma automática cada cierto avance de la cinta o modo no continuo: que sea el propio usuario el que genere el disparo cuando lo estime oportuno. Con estos parámetros vamos a ver el funcionamiento del simulador.</p>
						<p>Si nos vamos al panel automático en la sección inferior, vemos que existen dos botones: "crear ítem bueno" y "crear ítem malo". Si creamos un ítem bueno veremos que este aparece en el cero de coordenadas de la cinta de recogida a la cual pertenece. Todos los ítems se crean respecto al cero de coordenadas de la cinta a la cual pertenecen. En este caso, en este eje de coordenadas.</p>
						<p>Vamos a arrancar la cinta 1 y también vamos a arrancar la cinta 2 para que se vayan evacuando los productos. Este ítem, al ser creado como bueno, se considera válido para ser procesado por el robot, por tanto, el robot, cuando se encuentra en la zona de trabajo, en la zona verde, lo va a buscar. Un ítem malo no es procesable por el robot, por tanto, el robot, lo dejará pasar. Que un ítem sea bueno o se clasifique como bueno o malo es labor de la cámara de visión artificial, según los criterios que se definan para la aplicación.</p>
						<p>Bien, vamos a repetir la operación, pero en este caso, en cada disparo, vamos a generar tres ítems. Si repetimos la operación vemos que los tres ítems se han generado, como se ha comentado anteriormente, en el cero de coordenadas de la cinta de recogida, esto es, uno encima del otro. Esto es una situación que, habitualmente, no se suele dar en la vida real y no es, por lo general, deseable.</p>
						<p>Por tanto, se han añadido una serie de parámetros que permiten generar ítems alrededor del cero de coordenadas con una cierta variabilidad tanto en X como en la coordenada Y como, incluso, en el ángulo. Por ejemplo, vamos a probar añadiendo una variabilidad de 200 alrededor del cero del eje coordenado X lo cual quiere decir que, cada ítem, adoptará una X aleatoria entre estos dos rangos. La Y también tendrá su variabilidad y aprovecharemos para darle, incluso también, un ángulo al ítem, un ángulo alrededor del eje Z entre -45º y +45º de forma aleatoria.</p>
						<p>Vamos a probar y vamos generando disparos de forma manual. Vemos que los ítems ya no se superponen y circulan con una cierta separación entre ellos; aquí se ve más claramente, asemejándose más a lo que nos podríamos encontrar en la vida real.</p>
						<p>Bien, ahora vamos a probar el modo continuo. Si lo activamos, veremos que cada 200 mm de avance de cinta se genera un pulso de duración 100 milisegundos que desemboca en la generación de tres ítems sobre la cinta de recogida con esta variabilidad en sus coordenadas. Vamos a verlo. Sí, bien, aquí los vamos teniendo. Si nos fijamos, los ítems se van generando muy aleatoriamente, con una densidad más o menos elevada, pero algunos de ellos se pueden encontrar superpuestos. Por ejemplo aquí, estos dos de aquí están superpuestos o aquí, aquí vemos también un grupo de ellos que están superpuestos. Esto hay aplicaciones, sobre todo de clasificación, en los que puede ser habitual encontrarlo aunque no es algo que se suela buscar, porque luego las coordenadas Z también son importantes.</p>
						<p>En estos casos, a veces, para simular una llegada de material más realista, lo que se suele hacer es falsear o jugar, mejor dicho, con estos parámetros para que los ítems se generen con cierta aleatoriedad y cierta densidad, pero que nunca se superpongan los unos a los otros. Lo recomendable sería, en estos casos, que el disparo no corresponda con el campo de visión de la cámara, como tendría que ser lo habitual, sino que sea un pelín superior al propio ancho del ítem y además generar solamente un ítem por cada disparo.</p>
						<p>Por ejemplo, si activamos aquí un ítem por cada disparo y avance, o sea, disparo cada 100 mm de avance de cinta, que es un pelín superior a 80, obtendríamos, vemos que aún no lo hemos conseguido porque aún se siguen superponiendo, pero se estaría generando un ítem cada 100 mm de avance de cinta. El problema aquí es que, como sigue existiendo una cierta variabilidad alrededor de la coordenada X, el ítem de una foto puede superponerse al de la foto anterior. En este caso, para evitarlo, simplemente vamos a configurarlo en cero la variabilidad alrededor de la X.</p>
						<p>En este caso ya vemos que la Y sigue siendo aleatoria. La X siempre se genera en el cero pero, al estar separado 100 mm con respecto a la anterior foto y la siguiente, ya nunca se pisan. Podríamos conseguir, por ejemplo, en aplicaciones en las que el producto venga en fila india y equidistante entre sí, pues este efecto. Cogeríamos la Y, la variabilidad alrededor del eje Y y se lo bajaríamos a cero. Volveríamos y aquí veríamos cómo los ítems vienen equidistantes entre sí aunque no, aparentemente no, no parezcan hacerlo, debido al ángulo. La separación entre los centros de los ítems es equidistante e igual a 100, ¿a 100 o a 200?, a ver; a 100. Para verlo más claramente, podemos eliminar el ángulo alrededor del eje Z y aquí lo veríamos. Aquí ya vemos claramente que los ítems se generan equidistantes entre sí y vienen por la cinta de recogida en fila india. Hay aplicaciones en las que es así y que puede servir este simulador. Podemos separarlos un poco más, 200, y así simular una situación de una aplicación real de una forma más, más cómoda.</p>
						<p>Muy bien, además, para ajustar finamente porque, el simulador, digamos, si nos fijamos, el robot va a buscar el producto justo en el centro del ítem pero hay aplicaciones en las que esto no es así entonces, para ajustar un poco más el trabajo de captura de ítems tenemos los offsets que dependen o son distintos para cada robot. En este caso, como el ancho del ítem no son 80, si aplicamos un offset de 40 positivos en la X, veremos cómo el robot ya no lo coge en el centro, sino que lo coge justo en el borde. Esto sería con 40 positivos. Con 40 negativos, lo haría en el otro extremo. </p>
						<p>Esto puede ayudar, cuando se utiliza una cámara de visión artificial real, a ajustar pequeños desajustes que tenga el robot con respecto a esta cámara. Un robot en concreto. Puede ser que un robot tenga siempre un error conocido de 2 mm o de 3 mm respecto a la X o respecto a la Y y el siguiente robot, pues, no los tenga. Mediante estos parámetros podemos ajustar cada robot de forma que su herramienta se ponga encima del producto de la misma forma en todos los robots.</p>
						<p>Bien, otra cosa que hay que decir, antes de acabar, sería que el simulador de ítems se superpone al trabajo de una cámara de visión artificial real. Esto quiere decir que si, en este momento, tuviéramos una cámara de visión artificial leyendo objetos reales estos serían dados de alta encima de la cinta de recogida superponiéndose a los que se están dando de alta virtualmente a través del simulador. Por esto es recomendable, cuando se utiliza una cámara de visión artificial real leyendo producto real, no utilizar el modo continuo, o sea, desactivarlo y utilizar el modo no continuo para generar ítems en aquellos momentos en los que sospechamos que hay problemas con la cámara de visión artificial, por ejemplo, por una mala programación o porque se le ha dado un golpe y se ha desalineado y la cámara está disparando pero no aparecen, pero no aparecen ítems encima de la cinta de recogida.</p>
						<p>En estos casos, como sabemos exactamente dónde se va a generar el ítem a través del simulador, podemos comprobar realmente que este funciona y que, además, el robot va a cogerlo. En la vida real no veríamos ningún ítem porque es virtual pero sí veríamos que aparece encima de la cinta. Otra cosa que podemos hacer es que cuando se genera un ítem, si miramos en el buffer, digamos, de los 30 primeros ítems dados de alta en el registro de desplazamiento, podemos comprobar si la coordenada X aparece o no aparece en el registro de desplazamiento porque muchas veces, debido a un desajuste en la programación de la cámara, quizás el ítem si se está dando de alta en el sistema, pero con una Y tal que no aparece encima del dibujo de la cinta. La X sí que debería de aparecer porque la X es algo que, como el movimiento es a lo largo de la X, debería aparecer siempre. Entonces, en este caso, veríamos a lo mejor que no hay ítem; sí veríamos su X pero la Y, al ser muy alta o muy baja, pues hace que el ítem se dibuje fuera de esta área y no lo vemos con lo cual nos permitiría detectar si hay algún problema en la cámara de forma bastante rápida.</p>
					</div>
				</section>
				
				<section class="aspectos-container">
					<h3>Aspectos Clave</h3>
					<p><strong>Ubicación:</strong> Dirígete al panel de configuración haciendo clic en el botón correspondiente en el menú lateral izquierdo. Luego, pulsa el botón "Items" para acceder al panel de configuración del simulador de ítems.</p>
					<p><strong>Generación:</strong> El simulador puede generar un número configurable de ítems virtuales en modo continuo, generándolos automáticamente a intervalos regulares durante el avance de la cinta transportadora (ya sea de recogida o de entrega), o en modo no continuo, generándolos solo cuando el usuario lo solicita al pulsar el botón correspondiente en el panel de modo automático.</p>
					<p><strong>Variabilidad:</strong> Los ítems se generan en el punto cero de la cinta transportadora que los contiene, pero se puede configurar un rango de variabilidad en los ejes coordenados X e Y, así como en el ángulo del ítem. Esto permite simular una amplia gama de posiciones y orientaciones, replicando de manera más realista las condiciones en las que el robot debe operar. Así, es posible evaluar cómo responde el sistema ante diferentes escenarios de colocación y orientación de los ítems.</p>
					<p><strong>Offsets:</strong> El simulador de ítems imita el comportamiento de una cámara de visión real, en el sentido de que las coordenadas que entrega corresponden al centro geométrico del ítem. Los offsets permiten añadir una componente X, Y y angular a las coordenadas del ítem generado, de modo que el robot se dirija a una posición desfasada respecto a su centro, ya sea porque la naturaleza de la pinza lo requiere, por necesidades operativas, o para compensar pequeños desajustes mecánicos en la alineación entre los diferentes componentes del sistema (robot, cintas transportadoras, cámaras de visión).</p>
					<p><strong>Interacción con cámara:</strong> El simulador de ítems funciona en paralelo con la cámara de visión, por lo que se recomienda evitar el uso simultáneo de ambos elementos para prevenir posibles confusiones e interferencias. Cuando se opere con el simulador en modo continuo, es buena práctica desconectar o apagar la cámara de visión. De igual manera, al utilizar la cámara de visión, se debería configurar el simulador de ítems en modo no continuo. Si, mientras se trabaja con la cámara de visión, se ordena al simulador de ítems que genere un ítem en modo no continuo, este se generará virtualmente y se añadirá a la cinta junto con los ítems generados por la cámara de visión.</p>
				</section>	
			</article>
			
			<!-- Capítulo 11: Modo de operación "Giro Asíncrono" -->
			<article class="capitulo-container" id="capitulo11" style="display:none;">
				<iframe 
					src="https://www.youtube.com/embed/9eoQ_3-AcXQ?modestbranding=1&rel=0&enablejsapi=1" 
					frameborder="0"
					loading="lazy"
					allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" 
					allowfullscreen 
					aria-label="Vídeo que describe el funcionamiento del tipo de operación  Giro Asincrono del modo automático de la aplicación."> 
				</iframe>

				<section class="transcripcion-container">
					<div class="transcripcion-header" data-leccion="Lección 11">
						<span class="transcripcion-icon" aria-hidden="true">▶</span>
						<span class="transcripcion-text">Transcripción</span>
					</div>
					<div class="transcripcion-content">
						<p>En este vídeo veremos el tipo de operación "Giro Asíncrono". Para activar este modo de operación hemos de irnos al panel de configuración, a la sección donde se encuentran los parámetros del modo automático y escoger este tipo de operación, "Giro Asíncrono", para el robot que vamos a emplear. En este caso, solo vamos a emplear el robot número 1.</p>
						<p>Volvemos al panel de automático. Tenemos ya el robot en modo automático y simplemente vamos a hacer que la cinta de recogida arranque y empiezan a llegar ítems. Bien, vemos que, a medida que llegan los ítems, el robot se sitúa encima de ellos y ejecuta un giro, un giro de 360 grados con una velocidad tal que lo completa en 1 segundo y además en sentido horario. Si activáramos el contragiro "Giro Negativo", veríamos que el giro tiene lugar en el sentido opuesto. Ahora volvemos a invertir y efectivamente se invierte.</p>
						<p>Vemos también que los controles para este modo de trabajo son distintos que en otros modos: el modo "Pick & Place" o el modo "CNC"; no se necesitan más. En este caso, aunque aquí esté dibujada la cinta de entrega, la cinta de entrega no influye, no se utiliza en este modo de trabajo. La cinta de entrega solo se utiliza en el modo "Pick & Place".</p>
						<p>Y si vamos a ver la visualización 3D, veremos que, efectivamente, y de una forma más clara, el robot lo que hace es irse a cada uno de los ítems y efectúa un giro con su eje auxiliar de rotación. Esto puede estar indicado, pues, para operaciones en las que se tenga que dosificar algo encima de un elemento o realizar un lijado o cualquier otro tipo de operación.</p>						</div>
				</section>
				
				<section class="aspectos-container">
					<h3>Aspectos Clave</h3>
					<p><strong>Ubicación:</strong> Dirígete al panel de configuración haciendo clic en el botón correspondiente en el menú lateral izquierdo. Luego, pulsa el botón "Modo Automático" para acceder al panel de configuración del modo automático donde se podrá escoger el modo de operación "Giro Asincrono" de entre tres posibilidades.</p>
					<p><strong>Funcionalidad:</strong> En el modo de operación "Giro Asíncrono", el robot se dirige hacia el ítem objetivo en la cinta de entrega y, una vez alcanzado, se desplaza con él, sincronizado con la velocidad de la cinta, mientras su eje auxiliar de giro realiza un movimiento angular configurable en amplitud (ángulo), velocidad y sentido. Los parámetros de ajuste para este modo de operación están disponibles en el panel del modo automático y solo son accesibles cuando el robot está configurado para trabajar en este modo. Este modo de operación, al pertenecer al ámbito del "Material Working", no requeriría el uso de la cinta de entrega.</p>
					<p><strong>Usos:</strong> El modo "Giro Asíncrono" es ideal para realizar operaciones sobre un ítem que requieren un posicionamiento específico con el eje auxiliar, ya sea el de giro o la herramienta misma. Esto permite abarcar aplicaciones más allá del "Packaging", como dosificado, taladrado, ensamblado, pintado, entre otras.</p>
				</section>	
			</article>			
			
			<!-- Capítulo 12: Modo de operación CNC -->
			<article class="capitulo-container" id="capitulo12" style="display:none;">
				<iframe 
					src="https://www.youtube.com/embed/O_egAatg3Xk?modestbranding=1&rel=0&enablejsapi=1" 
					frameborder="0"
					loading="lazy"
					allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" 
					allowfullscreen 
					aria-label="Vídeo que describe las opciones disponibles en el panel de modo limpieza"> 
				</iframe>

				<section class="transcripcion-container">
					<div class="transcripcion-header" data-leccion="Lección 12">
						<span class="transcripcion-icon" aria-hidden="true">▶</span>
						<span class="transcripcion-text">Transcripción</span>
					</div>
					<div class="transcripcion-content">
						<p>En este vídeo veremos el tipo de operación CNC del modo de trabajo automático. Para activar este tipo de operación, hemos de entrar en el panel de configuración en la sección donde se encuentran los parámetros del modo automático y asegurarnos de que el robot que vamos a emplear tiene activada este tipo de operación: CNC.</p>
						<p>Volvemos al panel de automático. Bien, el tipo de operación CNC lo que realiza es dirigirse, lo que hace es dirigirse hacia el centro de un ítem cualquiera y ejecuta una serie de maniobras que se encuentran definidas dentro de un fichero ASCII mediante códigos G, que es un lenguaje específico de fabricación aditiva o control numérico.</p>						
						<p>El fichero que vamos a utilizar, este de aquí, contiene una serie de instrucciones que, básicamente, son movimientos lineales y una serie de marcas que, básicamente, son órdenes para activar o desactivar una herramienta, sea la herramienta que sea (no importa). Al final, tenemos una marca especial, que es la marca 7, que nos indica el final del programa y lo que hace el robot cuando detecta esta marca es abandonar el ítem y dirigirse, o bien al siguiente ítem si ya se encuentra dentro del área de trabajo, o bien a reposo, a la espera de un nuevo ítem.</p>
						<p>Además, para dar un poquito más de funcionalidades o de versatilidad a este tipo de función, cada una de estas marcas que implican una acción sobre la herramienta, bien de activación o desactivación, tenemos una serie de parámetros que se pueden configurar a tiempo real. Los más importantes, aparte de las velocidades de los movimientos G0 y G1 y sus rampas, son los retardos.</p>						
						<p>¿Por qué? Porque nos permiten generar o añadir una espera entre lo que es la orden de activación o desactivación de la herramienta y el siguiente movimiento que realizará el robot. Por ejemplo, si la herramienta fuera un taladro, al darle la orden de bajar taladro, esa bajada de taladro pues tarda un tiempo, el que sea, pongamos que sea, pues, medio segundo. Para garantizar de que el taladro está abajo, se le puede dar un retardo de inicio de un segundo y entonces, desde que damos la orden de bajar taladro hasta que este realmente se encuentra abajo, en contacto con el ítem, transcurre ese segundo, y a partir de ahí, pues, ya puede realizar el movimiento con el taladro abajo.</p>
						<p>Una vez realizado este movimiento, damos la orden de subir, pero esa orden no se ejecuta instantáneamente, también tarda un tiempo, por tanto, podemos configurar como retardo final más o menos la misma cantidad de tiempo, un segundo, para garantizar de que el taladro ya se encuentre arriba antes de iniciar el siguiente movimiento.</p>						
						<p>Una vez dicho esto, vamos a verlo en la práctica. Vamos a arrancar la cinta número uno y empezarán a llegar ítems. Aunque en la representación gráfica hay una cinta número dos, la de entrega, en este modo de trabajo no se utiliza esta cinta. Esta cinta de entrega solo se utiliza en el tipo de operación Pick and Place.</p>
						<p>Bueno, aquí aparece el primer ítem. Vamos lentos porque, como la operación tarda un tiempo, para que le dé tiempo a realizar toda la operación. Si nos fijamos, aquí en el indicador este, que tendría que estar vinculado con una salida digital, se observa que efectivamente se está activando y desactivando la herramienta en unos puntos muy determinados, básicamente se activa en el lado superior y en el lado inferior.</p>						
						<p>Exacto. Esto lo podríamos ver un poquito mejor en la representación 3D. Si nos vamos a la representación 3D, vemos lo que se ha explicado de una forma un poco más cercana a la realidad. El robot se va al punto central, luego se va a la esquina superior. Ahí da orden de activar herramienta y, un segundo después de dar esa orden, es cuando realiza el movimiento con la herramienta ya activa. Cuando llega al final de lo que es el lado superior, en esta esquina, lo que hace es dar orden de levantar la herramienta, en este caso, de desactivar la herramienta. En este caso, si fuera el taladro, hemos dicho, levantaría el taladro.</p>
						<p>Desde que se da la orden hasta que realmente se va a la otra esquina, pues, transcurre un segundo para garantizar que el taladro se encuentra arriba. Y así va repitiendo, pues, todo el proceso, una y otra vez. Esto proporciona al sistema, pues, una versatilidad bastante potente porque podemos definir el comportamiento del robot simplemente con un fichero externo. No hace falta entrar a modificar el código de la aplicación cada vez que queremos redefinir el comportamiento del robot.</p>						
						<p>Simplemente cogemos un cliente FTP, cogemos, o definimos, mejor dicho, la trayectoria a través de un fichero ASCII, se lo enviamos a la memoria del controlador mediante un cliente FTP, y el programa, el fichero, se lo dejamos en el área de ficheros del controlador. Este ficherito, pues, tiene un nombre determinado: GCodeRobot1. Es un nombre muy concreto y solo sirve para el robot número uno. El robot número dos tendría GCodeRobot2 y así. Cada robot podría tener un perfil o una maniobra asociada distinta.</p>					
					</div>
				</section>				
				
				<section class="aspectos-container">
					<h3>Aspectos Clave</h3>
					<p><strong>Ubicación:</strong> Dirígete al panel de configuración haciendo clic en el botón correspondiente en el menú lateral izquierdo. Luego, pulsa el botón "Modo Automático" para acceder al panel de configuración del modo automático donde se podrá escoger el modo de operación "CNC" de entre tres posibilidades.</p>
					<p><strong>Funcionalidad:</strong> Este modo permite al robot leer un fichero ASCII desde la memoria del controlador, el cual describe una secuencia de movimientos y órdenes para activar/desactivar la pinza haciendo uso de códigos G. El robot se desplazará al centro del ítem objetivo y luego ejecutará las tareas según las instrucciones del fichero. Al finalizar, el robot se dirigirá al siguiente ítem si está disponible; de lo contrario, regresará a la posición de reposo. Además, se pueden configurar parámetros como las velocidades de los movimientos y los retardos, los cuales gestionan los tiempos de espera para garantizar que la herramienta haya completado la orden de activación o desactivación antes de iniciar el siguiente movimiento.</p>
					<p><strong>Versatilidad:</strong> El modo CNC ofrece gran flexibilidad al permitir definir el comportamiento del robot mediante ficheros externos (GCode), sin necesidad de modificar el código de la aplicación. Estos ficheros se cargan en la memoria del controlador usando un cliente FTP y pueden ser específicos para cada robot, lo que permite configurar perfiles o maniobras distintas. Esto facilita la adaptación de la línea robótica en tiempo real para producir tiradas cortas sin tiempos de parada significativos.</p>					
				</section>	
			</article>				
			
			<!-- Capítulo 13: Reglas de selección de ítems -->
			<article class="capitulo-container" id="capitulo13" style="display:none;">
				<iframe 
					src="https://www.youtube.com/embed/XkIW-Sa0lVw?modestbranding=1&rel=0&enablejsapi=1"
					frameborder="0"
					loading="lazy"
					allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" 
					allowfullscreen 
					aria-label="Vídeo que describe las opciones de selección de ítems incluidas en la aplicación."> 
				</iframe>

				<section class="transcripcion-container">
					<div class="transcripcion-header" data-leccion="Lección 13">
						<span class="transcripcion-icon" aria-hidden="true">▶</span>
						<span class="transcripcion-text">Transcripción</span>
					</div>
					<div class="transcripcion-content">
						<p>En este vídeo se verá cómo funciona el selector de objetivos del modo automático de trabajo. En una situación real, es muy probable que, en el área de trabajo del robot, esta área de color verde, se encuentren varios ítems a procesar y, de alguna manera, se le ha de decir al robot cuál de estos ítems debe ser el primero. Para ello, se utilizan una serie de reglas. Las reglas que incluye la plataforma de desarrollo de aplicaciones multirrobot son tres y se pueden encontrar en el panel de configuración, en la sección de parámetros del modo automático; en esta sección de aquí, en esta zona. Tenemos tres para la cinta de recogida u operación de "picking" y los mismos tres para la cinta de entrega u operación de "place".</p>
						<p>Vamos a ver un ejemplo de cada, que es como mejor se entiende. Primero seleccionaremos para el robot número 1 la regla de selección “cercana”. Volvemos al panel automático y vamos a desinhibir el robot para que empiece a procesar los ítems que se encuentran dentro de su área de trabajo. Como la regla de selección es la “cercana”, lo que va a hacer es buscar el ítem que se encuentre más cerca del cero de coordenadas del robot, que estaría marcado por estos ejes cartesianos. En este caso, debería ser el 4, pero el 4, si nos fijamos, está marcado en gris.</p>
						<p>¿Esto por qué es? Porque este ítem ha sido marcado para no ser procesado debido a que se encuentra más allá de los límites software de este robot. Los límites software, si los vamos a.… hacemos una rápida visita, se encuentran aquí para este robot 1 (el robot 2 tiene otros límites distintos) están fijados en -400. Así que es muy probable de que este ítem, el 4, tenga una cota Y inferior a -400 y, por tanto, no debe ser procesado. Entonces, vamos a darle al botón inhibir para habilitar el robot y vamos a ver lo que hace. Vemos que se va al 5 porque su cero de coordenadas es el más cercano al cero del robot, luego al 3, luego seguramente al 2, al 7, siempre está escogiendo aquel cuyo centro se encuentre más cercano al centro de coordenadas del robot, hasta quedarse sin candidatos viables.</p>
						<p>Bien, vamos a inhibir el robot para que no trabaje y hacemos llegar más ítems al área de trabajo del robot. Por ejemplo, aquí. Fijémonos que estos 7 ítems, que estaban marcados como inviables para el robot número 1 porque su cota Y está más abajo del límite inferior Y, han quedado desmarcados al rebasar la zona de trabajo del robot número 1. Esto es así porque el robot número 2 debe de tener otros límites software. Por tanto, lo que no era válido para el robot 1 no tiene por qué ser también inválido para el robot número 2.</p>
						<p>Entonces, volviendo a lo que estábamos haciendo, volvemos al panel de configuración y en este caso seleccionamos otra regla: la “lejano negativa”. Lejana negativa quiere decir que el robot escogerá aquel ítem cuyo cero de coordenadas se encuentre más lejos del cero de coordenadas del robot, pero en sentido negativo respecto al eje cartesiano X. En este caso, muy probablemente será el 1. Vamos a verlo. Exacto. Luego, el siguiente que va a procesar será el 13 porque es el siguiente viable más lejano en negativo y así. El 8, dependiendo si está dentro o fuera del área verde, pues lo procesará o no. En este caso, está fuera por un pelín, no lo procesa.</p>
						<p>Vamos a inhibir y hacemos llegar más ítems al área de trabajo. Vale, ya tenemos unos cuantos y vamos a seleccionar la última de las reglas que nos faltaba por probar: la “lejana positiva”, que es exactamente igual que lo que hemos visto hasta ahora, pero cogerá el ítem cuyo centro se encuentre más lejos del cero de coordenadas del robot, pero en sentido positivo. Es decir, en este caso sería el 2. Vamos a habilitar el robot y así... ahora será el 3.</p>
						<p>No hay una regla de selección mejor que otra; depende de la aplicación y lo que se pretende de ella. En este caso se incluyen estas tres porque son las más evidentes, pero corresponde al desarrollador de la máquina decidir cuál es la más correcta para su máquina y, si ninguna de ellas lo es, desarrollar la suya propia.</p>
					</div>
				</section>
				
				<section class="aspectos-container">
					<h3>Aspectos Clave</h3>
					<p><strong>Ubicación:</strong> Dirígete al panel de configuración haciendo clic en el botón correspondiente en el menú lateral izquierdo. Luego, pulsa el botón "Modo Automático" para acceder al panel de configuración de dicho modo, donde encontrarás la sección "Reglas selección ítem". Desde allí, podrás escoger qué reglas deseas aplicar a las cintas de recogida y/o entrega.</p>
					<p><strong>Funcionalidad:</strong> En el área de trabajo del robot, pueden existir muchos ítems (destinos), por lo que es necesario establecer una regla que le ayude a decidir a cuál dirigirse primero. El template de robótica incluye tres reglas: "cercana", "lejano negativo" y "lejano positivo", que indican al robot el siguiente ítem a procesar, basándose en su proximidad al centro de coordenadas o en su distancia en sentido positivo o negativo.</p>
					<p><strong>Límites software:</strong> Las reglas de selección de ítems consideran los límites software configurados para cada robot, por lo que los ítems que están más allá de estos límites no se tienen en cuenta. Dado que cada robot tiene sus propios límites, un ítem puede ser válido para uno y no para otro. Los ítems fuera de los límites software se representan en color gris en el panel de modo automático.</p>
					<p><strong>Ampliabilidad:</strong> La elección de la regla de selección más adecuada depende de cada aplicación, por lo que no hay una mejor que otra. Aunque las reglas incluidas pueden aplicarse a un gran número de situaciones, son bastante básicas y podrían no ser adecuadas para aplicaciones específicas. Sin embargo, los usuarios avanzados pueden ampliarlas y añadir sus propias reglas si las existentes no satisfacen sus necesidades.</p>

				</section>	
			</article>			

			<!-- Capítulo 14: Tipo de entrega en punto fijo -->
			<article class="capitulo-container" id="capitulo14" style="display:none;">
				<iframe 
					src="https://www.youtube.com/embed/LxAqXAZwxf0?modestbranding=1&rel=0&enablejsapi=1"
					frameborder="0"
					loading="lazy"
					allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" 
					allowfullscreen 
					aria-label="Vídeo que describe el funcionamiento del tipo de entrega en punto fijo del modo automático de la aplicación."> 
				</iframe>

				<section class="transcripcion-container">
					<div class="transcripcion-header" data-leccion="Lección 14">
						<span class="transcripcion-icon" aria-hidden="true">▶</span>
						<span class="transcripcion-text">Transcripción</span>
					</div>
					<div class="transcripcion-content">
						<p>En este vídeo veremos el primero de los tipos de entrega que posee la operación "Pick and Place" del modo automático: la entrega sobre punto fijo. Para activar este tipo de entrega deberíamos irnos al panel de configuración, a las opciones del modo automático, y asegurarnos que todos los robots que vamos a emplear en esta operativa se encuentran configurados con el tipo de operación "Pick and Place" y el tipo de entrega "Punto Fijo". Vamos navegando a través de todos los robots, vamos a emplear solamente los tres primeros, y confirmamos que realmente se encuentran en esta configuración.</p>
						<p>Volvemos al panel de automático, arrancamos la cinta de recogida y empezaran a llegar ítems en posiciones y ángulos arbitrarios. Veremos que cada uno de los robots toma estos ítems y genera un patrón sobre la cinta de entrega. El patrón definido para cada uno de los robots es distinto, simplemente para demostrar la utilidad de este método. Normalmente este método se suele utilizar cuando la cinta de entrega se encuentra detenida, por ejemplo, porque tenemos una caja o un receptáculo en una posición determinada y podemos ejecutar este método.</p>
						<p>Vemos que el patrón que se encuentra diseñado para el robot número 1, pues, es simplemente una cuadrícula de 9 ítems; el robot número 2 también son 9 ítems, pero con ángulos y en un orden distinto, mientras que el robot número 3 siguen siendo 9 ítems, pero realiza 3 filas de 3 ítems cada una a 3 niveles digamos. Una vez acabado el patrón, el robot vuelve a repetirlo encima del ya creado porque la plataforma de desarrollo de aplicaciones multirrobot es abierta y no tiene ninguna maniobra para evacuar este producto. Esta maniobra se tendría que crear a propósito en función de una serie de condiciones externas.</p>
						<p>Bien, si queremos ver el resultado en tres dimensiones, podemos venir aquí y verlo en tres dimensiones; seguramente ahora los robots están detenidos porque ya hemos llegado al total de objetos que permite gestionar la cinta de entrega. Vamos a borrarlos, ahí está, y así podemos volver a reiniciar. Y ahí vemos la operativa. Vamos a darle la vuelta, quizás se verá mejor así, la ampliamos. Vemos que el orden, digamos, de creación de cada patrón es distinto: aquí estamos creando 3 niveles de ítems, aquí solo tenemos 1 y otro aquí pero con ángulos distintos.</p>
						<p>Bien, volvamos al programa. El diseño de estos patrones se tiene que realizar desde el panel de configuración: volvemos al modo automático y pulsamos sobre el botón "Definición" del robot en cuestión. En este caso vemos que tenemos disponibles 10 ítems, no necesariamente tenemos que emplearlos todos; para eso está la columna de habilitar, aquí en este caso solo utilizamos 9, y cada ítem tiene sus propias coordenadas X, Y, y Z y el ángulo. El patrón se formará de forma secuencial, es decir, primero realizará el primer ítem, las coordenadas del primer ítem, luego el segundo, el tercero y cuarto.</p>
						<p>Cada robot tiene creado su propio esquema de patrón, por ejemplo, en este caso tenemos ángulos distintos y en el último sí que ya tenemos los 10 ítems seleccionados. Por esto, si vamos a fijarnos en la representación 3D, aquí tenemos 3 filas de 3 y una última 4 que tiene el décimo ítem.</p>					</div>
				</section>
				
				<section class="aspectos-container">
					<h3>Aspectos Clave</h3>
					<p><strong>Ubicación:</strong> Dirígete al panel de configuración haciendo clic en el botón correspondiente en el menú lateral izquierdo. Luego, pulsa el botón "Modo Automático" para acceder al panel de configuración de dicho modo, donde encontrarás la sección "Tipo Entrega". Desde allí, podrás escoger de qué manera se depositarán los ítems sobre la cinta transportadora de entrega.</p>
					<p><strong>Funcionalidad:</strong> Este tipo de entrega, que sólo tiene sentido al utilizarse el tipo de operación "Pick & Place", permite que el robot deposite el ítem en una posición fija previamente configurada. Es útil en aplicaciones donde el ítem, por ejemplo, debe ser colocado en una caja o enviado a una estación de descarte.</p>
					<p><strong>Creación de mosaicos:</strong> El tipo de entrega "Punto Fijo" permite a cada robot crear su propio mosaico, compuesto por hasta 10 ítems. Para ello, debes pulsar el botón "Definición", ubicado a la derecha de la selección de este tipo de entrega. Luego, utiliza la casilla "Habilitar" para activar los ítems que formarán el mosaico y configura sus coordenadas XYZ y el ángulo de giro.</p>
				</section>	
			</article>

			<!-- Capítulo 15: Tipo de entrega en caja -->
			<article class="capitulo-container" id="capitulo15" style="display:none;">
				<iframe 
					src="https://www.youtube.com/embed/AkLb1QUprvQ?modestbranding=1&rel=0&enablejsapi=1"
					frameborder="0"
					loading="lazy"
					allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" 
					allowfullscreen 
					aria-label="Vídeo que describe el funcionamiento del tipo de entrega en caja del modo automático de la aplicación."> 
				</iframe>

				<section class="transcripcion-container">
					<div class="transcripcion-header" data-leccion="Lección 15">
						<span class="transcripcion-icon" aria-hidden="true">▶</span>
						<span class="transcripcion-text">Transcripción</span>
					</div>
					<div class="transcripcion-content">
						<p>En este vídeo veremos el segundo de los tipos de entrega que posee la operación "Pick & Place" del modo automático: la entrega sobre caja. Para activar este tipo de entrega hemos de irnos al panel de configuración, a la sección de parámetros del modo automático, y asegurarnos de que todos los robots se encuentren trabajando bajo el tipo de operación "Pick & Place" y el tipo de entrega "Caja". El robot número 1 es así, el 2 también, el 3 también y el 4 también. Perfecto.</p>
						<p>Volvemos al panel de automático y damos marcha a las dos cintas, tanto la de recogida como la de entrega, y empezarán a llegar, pues, una serie de ítems en posiciones y ángulos aleatorios, y una serie de cajas también en posiciones y ángulos totalmente aleatorios. Esto en la vida real tampoco es tan extremo, pero se ha hecho así, se ha simulado así, para ver la potencia de este método.</p>
						<p>Vemos que el robot número 1 está, de momento, asumiendo todo el trabajo hasta que, debido a circunstancias, no… se escape alguna caja. Por ejemplo, la 9 se le ha escapado, entonces el robot número 2 acabará el proceso con la 9 y la 11, que también se ha escapado, y la 14. Aquí vemos.</p>
						<p>Es importante observar cómo el ángulo del eje de giro auxiliar del robot adopta el ángulo de la pieza de recogida y de la caja de entrega. Esto lo podemos ver con la flechita esta. Y luego, si queremos ver esto un poquito mejor en tres dimensiones, podemos dirigirnos aquí. Y aquí vemos el proceso un poquito más realista. Vemos que los ítems se cogen en el ángulo correcto y se rotan durante la trayectoria hacia el objetivo en el ángulo destino, y que solo se procesan las cajas que están vacías realmente; no se introducen 2 ítems en la misma caja.</p>																		
					</div>
				</section>
				
				<section class="aspectos-container">
					<h3>Aspectos Clave</h3>
					<p><strong>Ubicación:</strong> Dirígete al panel de configuración haciendo clic en el botón correspondiente en el menú lateral izquierdo. Luego, pulsa el botón "Modo Automático" para acceder al panel de configuración de dicho modo, donde encontrarás la sección "Tipo Entrega". Desde allí, podrás escoger de qué manera se depositarán los ítems sobre la cinta transportadora de entrega.</p>
					<p><strong>Funcionalidad:</strong> Este tipo de entrega, que solo tiene sentido en una operación "Pick & Place", permite que el robot deposite el ítem en el interior de una caja en movimiento con coordenadas y ángulos arbitrarios. Para esto, se requiere una cámara de visión que determine las coordenadas y el ángulo de la caja en el momento en que ingresa a la cinta transportadora de entrega. Este tipo de entrega es útil, por ejemplo, en la industria de "Food & Beverage" para el empaquetado de productos como botellas o productos envasados al vacío en cajas que se transportan de forma irregular por una cinta de entrega. La capacidad de considerar la posición y el ángulo aleatorio de la caja asegura un proceso de empaque eficiente y preciso..</p>
					<p><strong>Adaptación al vuelo:</strong> Durante su trayectoria hacia la cinta de entrega, el robot ajusta el ángulo de su eje de giro para coincidir con el del ítem a recoger. Una vez que ha recogido el ítem, el robot ajusta nuevamente el ángulo de su eje de giro durante el trayecto hacia la cinta de entrega, asegurando que coincida con el ángulo de la caja en la que debe depositar el ítem. Esta adaptación se realiza de manera continua a lo largo de toda la trayectoria para garantizar el movimiento más suave posible.</p>
				</section>	
			</article>

			<!-- Capítulo 16: Tipo de entrega en cinta de cangilones -->
			<article class="capitulo-container" id="capitulo16" style="display:none;">
				<iframe 
					src="https://www.youtube.com/embed/gmYwqyCr1Fs?modestbranding=1&rel=0&enablejsapi=1"
					frameborder="0"
					loading="lazy"
					allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" 
					allowfullscreen 
					aria-label="Vídeo que describe el funcionamiento del tipo de entrega en cinta de canjilones del modo automático de la aplicación."> 
				</iframe>

				<section class="transcripcion-container">
					<div class="transcripcion-header" data-leccion="Lección 16">
						<span class="transcripcion-icon" aria-hidden="true">▶</span>
						<span class="transcripcion-text">Transcripción</span>
					</div>
					<div class="transcripcion-content">
						<p>En este vídeo veremos el tercero de los tipos de entrega que posee la operación "Pick & Place" del modo automático: la entrega sobre cinta de cangilones. Una cinta de cangilones no deja de ser más que una cadena que se mueve sin fin y que está compuesta por un número determinado de receptáculos separados entre sí una distancia conocida. No es necesario una cámara de visión artificial para detectar estos receptáculos, pero sí que es preciso, en algún momento dado, realizar una búsqueda de Home: referenciar uno de estos receptáculos.</p>
						<p>En una situación real, lo que haríamos sería arrancar la cinta número 2 hasta que uno de los receptáculos hiciera llegar un pivote mecánico sobre un detector inductivo o similar. En ese momento, veríamos que todas las posiciones de la cinta de cangilones quedan completamente identificadas y ya se puede trabajar con ellas. Bien, para trabajar en este modo de entrega, lo que hemos de hacer es irnos al panel de configuración, a la sección donde se encuentran los parámetros del modo automático, y asegurarnos de que todos los robots involucrados se encuentran trabajando bajo el tipo de operación "Pick & Place" y tipo de entrega "Cangilón", tanto el 1 como el 2, como el 3, como el 4.</p>
						<p>Además, en este caso concreto, como vamos a trabajar con cuatro robots, lo que vamos a hacer, para que haya un reparto equitativo de carga, es que el robot número 1 trabaje por un reparto de carga zonal, el 2 también, el 3 también, y el 4 coja todo lo que pueda coger (no utilice ningún reparto de carga). Bien, vamos a arrancar la cinta número 1 y empezarán a llegar los ítems en posiciones y ángulos totalmente aleatorios. Y a medida que entre un ítem de la zona que le corresponda a cada robot en su área de trabajo, lo irá procesando.</p>
						<p>Aquí vemos como cada robot coge los ítems de su zona y los va depositando en la cinta de cangilones. Observamos que van quedando una serie de huecos vacíos debido a las distintas velocidades tanto de la cinta de entrega como la de recogida. En ciertas situaciones no conviene que la cinta de cangilones siga avanzando con algún hueco en la cinta de cangilones. Por ejemplo, el 7 no debería haber pasado ¿vale?. Entonces, para evitar estas situaciones, se ha añadido una opción en el modo cangilones que hemos llamado "Detener cinta" y que normalmente se activa en el último de los robots involucrados. Vamos a poner que estamos en el 4, detener cinta y volvemos al panel automático. Aquí veremos que ahora, en teoría, no tendría que atravesar el límite, digamos, de la zona de trabajo del robot 4 ningún cangilón vacío.</p>
						<p>Ahora llegarán unos cuantos. A ver si nos da tiempo verlo. Ahí, se ha parado, se ha parado automáticamente porque este cangilón, el 52, se encontraba libre. Ahora, al ser ocupado por un nuevo ítem, la cinta vuelve a arrancar automáticamente. De esta forma garantizamos que ningún cangilón queda vacío más allá de la zona, digamos, de influencia de todo lo que es la línea robótica.</p>
						<p>La visualización 3D relacionada no aporta tampoco mucha más información; simplemente vemos la cinta de cangilones, pues, que se van rellenando los huecos a medida que va avanzando, pero ningún hueco debería sobrepasar el área máxima de trabajo del último robot. Ahí tenemos. Aquí ya se ha parado, exacto, se ha parado porque este hueco está libre y ahora ha vuelto a arrancar.</p>	
					</div>
				</section>
				
				<section class="aspectos-container">
					<h3>Aspectos Clave</h3>
					<p><strong>Ubicación:</strong> Dirígete al panel de configuración haciendo clic en el botón correspondiente en el menú lateral izquierdo. Luego, pulsa el botón "Modo Automático" para acceder al panel de configuración de dicho modo, donde encontrarás la sección "Tipo Entrega". Desde allí, podrás escoger de qué manera se depositarán los ítems sobre la cinta transportadora de entrega.</p>
					<p><strong>Funcionalidad:</strong> La cinta de cangilones es un sistema de transporte que utiliza una cadena continua con receptáculos elevados, conocidos como cangilones, que están espaciados uniformemente a lo largo de la cinta. Cada cangilón actúa como un contenedor para transportar ítems de forma ordenada y eficiente. La cinta avanza en un movimiento continuo, moviendo los cangilones en una trayectoria fija. A diferencia de los sistemas que utilizan visión artificial, la cinta de cangilones no requiere una cámara para identificar cada cangilón. Sin embargo, es crucial establecer una referencia inicial precisa para determinar la posición cero de la cinta de cangilones. Esta referencia inicial asegura que los ítems sean recogidos y depositados en los cangilones de manera consistente.</p>
					<p><strong>Manejo de huecos:</strong> En algunas aplicaciones, es crucial evitar que la cinta de cangilones abandone la zona robótica con cangilones vacíos. Para abordar esta necesidad, se ha implementado una opción denominada "Detener cinta", que puedes encontrar a la derecha de la selección de este tipo de entrega. Esta opción se activa en el último robot de la línea y permite detener la cinta de cangilones si se detecta un cangilón vacío a punto de abandonar su área de trabajo. Una vez que el cangilón ha sido llenado por el robot, la cinta se reinicia automáticamente para reanudar el transporte.</p>				
				</section>	
			</article>				

			<!-- Capítulo 17: Reparto de carga entre robots -->
			<article class="capitulo-container" id="capitulo17" style="display:none;">
				<iframe 
					src="https://www.youtube.com/embed/xk3Bc-ihg20?modestbranding=1&rel=0&enablejsapi=1"
					frameborder="0" 
					loading="lazy"
					allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" 
					allowfullscreen 
					aria-label="Vídeo que describe las opciones de reparto de carga entre robots utilizadas por la aplicación."> 
				</iframe>

				<section class="transcripcion-container">
					<div class="transcripcion-header" data-leccion="Lección 17">
						<span class="transcripcion-icon" aria-hidden="true">▶</span>
						<span class="transcripcion-text">Transcripción</span>
					</div>
					<div class="transcripcion-content">
						<p>En este vídeo veremos las opciones de reparto de carga entre robots incluidas en la aplicación. Para ello, nos dirigiremos al panel de configuración y a la sección donde se encuentran los parámetros relativos al modo automático de trabajo.</p>
						<p>En este panel vemos que, en cuanto a reparto de carga, existen tres posibilidades: o no utilizar ningún reparto de carga, o utilizar un reparto de carga basado en la zona de la cinta donde se encuentra el ítem, o bien un reparto de carga basado en la categoría que la cámara asigna a cada ítem.</p>
						<p>Para comprobar el comportamiento de la máquina ante cada una de estas tres posibilidades, nos aseguraremos de que los cuatro robots que vamos a emplear en el proceso poseen el mismo tipo de reparto de carga. En este caso, “ninguno”. Nos dirigiremos al panel automático y arrancaremos las cintas.</p>
						<p>En esta modalidad, como no existe ningún reparto de carga, cada robot intentará procesar todos los ítems que entren en su zona de influencia. Aquellos que no consiga procesar seguirán su camino hasta alcanzar la zona de influencia del siguiente robot, que hará lo propio, y así hasta el último de los robots.</p>
						<p>Vemos ya, a simple vista, que los primeros robots están asumiendo la mayor parte de la carga de trabajo, mientras que los últimos robots tienden a asumir una carga mucho menor. Vemos que el robot número 1 y 2 están continuamente procesando ítems sin parar, mientras que el robot número 3 está solamente el 50% de su tiempo, más o menos, procesando ítems y el cuarto robot no procesa ninguno; no hay ningún ítem que alcance su zona de influencia.</p>
						<p>Esto puede tener consecuencias negativas en cuanto a mantenimiento porque, evidentemente, los robots que más trabajan se van a gastar antes y van a necesitan más planes de mantenimiento que los últimos. Por tanto, muy probablemente, a lo largo del año, se produzcan muchas más paradas técnicas que si el reparto estuviera más equilibrado. Luego, los planes de mantenimiento predictivo y preventivo se podrían llegar a complicar porque necesitarían considerar no la máquina como un conjunto, sino cada uno de los robots como si fueran máquinas individuales.</p>
						<p>Bien, vamos a ver el comportamiento del sistema con otro reparto de carga. Nos dirigiremos al panel de configuración y, en este caso, seleccionaremos un reparto de carga “zonal” en cada uno de los cuatro robots.</p>
						<p>Bien, en este tipo de reparto de carga, lo que se hace es dividir el ancho de la cinta de recogida en tantas zonas como robots se encuentren activos, esto es, en automático y trabajando. En este caso, como tenemos 4, el ancho de la cinta se divide en 4 secciones, cada una con el 25% del ancho total de la cinta. De tal modo que los ítems que circulan por el 25%, por el primer 25% del ancho de la cinta, serán asignados al primer robot. El segundo robot cogerá solamente los ítems que se encuentren dentro del siguiente 25%. El tercer robot solo cogerá los ítems que se encuentren en el tercer 25% y el cuarto robot hará lo propio con los ítems que se encuentren en el último 25%.</p>
						<p>De esta forma, ya vemos que el reparto está más equilibrado. Tal vez los primeros robots estén produciendo menos tiempo, pero eso es porque el reparto está más equilibrado y los últimos dos están produciendo más que antes, que cuando no teníamos ningún reparto de carga.</p>
						<p>Si ahora, por ejemplo, cogiéramos el robot número 2 y lo inhibiéramos, el sistema se autoconfiguraría y las zonas se dividirían no en 4, sino en 3, puesto que solamente tendríamos tres robots en automático y produciendo. El sistema es el mismo: el primer robot recogerá solamente los ítems que se encuentren en el primer tercio del ancho de la cinta. El segundo no va a coger ninguno porque está inhibido. El tercer robot solamente cogerá los ítems que se encuentren en la parte central de la cinta, en el segundo tercio, y el cuarto robot solo cogerá los que se encuentren en el último tercio de la cinta, el último 33%.</p>				
						<p>Esto puede ser útil en aquellos casos en los que, por avería o por otras causas, se deba de detener uno de los robots y necesitemos que el resto sigan produciendo. Se podría bajar la velocidad de la cinta y los tres robots supervivientes asumirían la totalidad de la carga.</p>
						<p>Bien, vamos a parar cintas y, en este caso, vamos a seleccionar el último tipo de reparto de carga existente, que sería el reparto de carga basado en la categoría que la cámara asigna a cada ítem.</p>						
						<p>Haremos lo mismo: nos dirigiremos al robot 1, cámara; robot 2, cámara; robot 3, cámara y robot 4... Bien, en este caso, la cámara asignará una categoría a cada ítem en función de sus características y el operario podría asignar cada una de estas categorías para ser procesadas por un robot u otro.</p>						
						<p>En este ejemplo, vamos a dividir la carga también un poco de forma equilibrada y asignaremos la categoría 0 al robot 1, la categoría 1 al robot 2, la 2 al 3 y la 3 al 4 y la cuarta categoría se la asignaremos a todos los robots, de forma que si hay un ítem que tenga categoría 4, será procesado por cualquiera de los robots.</p>						
						<p>Vamos a hacer aceptar, nos vamos al panel de automático. Bien, vamos a borrar la cinta para que no nos cree confusión y el segundo robot, que está inhibido, lo vamos a habilitar y ahora vamos a arrancar la cinta de nuevo. Dado que el generador de ítems está generando ítems de forma aleatoria, las categorías también son aleatorias. Por tanto, muy probablemente la distribución sea bastante equitativa.</p>						
						<p>Vemos que el robot número 1 solamente está cogiendo ítems que hayan sido clasificados como categoría 0 o como categoría 4. el robot número 2 solo cogerá los de categoría 1 y 4, el robot número 3 cogerá los de categoría 2 y 4 y el cuarto robot los de categoría 3 o 4. Algunos ítems puede ser que se escapen, por ejemplo, si algún ítem de categoría 0 no ha sido procesado por el primer robot ya no lo será procesado por ninguno y se escapará. Los ítems de categoría 4 es menos probable que se escapen porque, si no fueran procesados por el robot 1, aún podrían ser procesados por el 2, por el 3 o por el 4. </p>		
						<p>Hemos visto que se ha escapado uno. Para evitar esto, siempre que la aplicación lo permita, es posible utilizar repartos de carga distintos para cada robot. Lo habitual es que el cuarto robot intente procesar todo lo que el resto de robots no pueda procesar. Para eso, lo que se puede hacer es dirigirnos al panel de configuración y, para el cuarto robot solamente, indicar que no deseamos ningún reparto de carga. En este caso, el robot número 4 va a procesar todos los ítems que lleguen a su zona de influencia, siempre y cuando pueda, claro. Esto no todas las aplicaciones lo permiten.</p>
					</div>
				</section>
				
				<section class="aspectos-container">
					<h3>Aspectos Clave</h3>
<!-- FALTA -->		<p><strong>Tipos de Reparto de Carga:</strong></p>
					<ul>
						<li><strong>Sin Reparto de Carga:</strong> Los robots intentan procesar todos los ítems en su zona de influencia. Esto puede resultar en una distribución desigual de la carga de trabajo, con los primeros robots procesando más ítems que los últimos, lo que puede afectar el mantenimiento y la eficiencia operativa.</li>
						<li><strong>Reparto de Carga Zonal:</strong> Se divide el ancho de la cinta en zonas específicas para cada robot. Esto equilibra la carga de trabajo y el desgaste en los robots mejorando la eficiencia global. Si un robot se inhibe, el sistema ajusta automáticamente el reparto entre los restantes, asegurando continuidad en la producción.</li>
						<li><strong>Reparto Basado en Categorías:</strong> Los ítems son clasificados en categorías por la cámara, y cada robot está asignado a procesar ciertas categorías. Esto permite una distribución específica y controlada de los ítems, optimizando el procesamiento al asegurar que cada robot maneje los ítems que mejor se ajusten a sus capacidades.</li>
					</ul>
					<p><strong>Flexibilidad del reparto de Carga:</strong></p>
					<ul>
						<li><strong>Adaptabilidad:</strong> El sistema puede ajustar el reparto de carga automáticamente si uno de los robots se inhibe, redistribuyendo el trabajo entre los restantes para mantener la producción. Esto asegura que la operación continúe sin interrupciones significativas, adaptándose a cambios en la disponibilidad de los robots.</li>
						<li><strong>Multiconfiguración:</strong> Es posible configurar cada robot con un tipo específico de reparto de carga. Por ejemplo, algunos robots pueden estar configurados para procesar todos los ítems que los otros robots no pueden manejar, mientras que otros pueden estar asignados a procesar ítems según categorías o zonas específicas. Esta flexibilidad asegura una cobertura completa y minimiza el riesgo de que algunos ítems no sean procesados adecuadamente.</li>
					</ul>
				</section>	
			</article>			
			
			<!-- Capítulo 18: Ajustes trayectoria modo automático -->
			<article class="capitulo-container" id="capitulo18" style="display:none;">
				<iframe 
					src="https://www.youtube.com/embed/V773qxzeBNo?modestbranding=1&rel=0&enablejsapi=1"
					frameborder="0"
					loading="lazy"
					allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" 
					allowfullscreen 
					aria-label="Vídeo que describe los diversos parámetros existentes para configurar la trayectoria utilizada en el modo automático."> 
				</iframe>

				<section class="transcripcion-container">
					<div class="transcripcion-header" data-leccion="Lección 18">
						<span class="transcripcion-icon" aria-hidden="true">▶</span>
						<span class="transcripcion-text">Transcripción</span>
					</div>	
					<div class="transcripcion-content">
						<p>En este vídeo se describirán las opciones existentes para configurar la trayectoria que seguirá el robot en modo automático. Para ello, nos dirigiremos al panel de configuración y a la sección donde se encuentran los parámetros relativos al modo automático de trabajo.</p>
						<p>Tal como vemos en este panel, una trayectoria de Pick&Place es básicamente un spline cuya cota superior corresponde con la cota Z de la posición de reposo, y las inferiores con la cota Z de los sistemas de coordenadas empleados por la cinta de entrega y de recogida. Vamos a utilizar la representación 3D para ver el aspecto de esta trayectoria. Para ello, nos dirigiremos al panel automático y desinhibiremos el robot.</p>
						<p>Vemos a través de la sombra que deja el TCP a lo largo de la trayectoria que esta es efectivamente un spline. Este tipo de movimientos es bastante adecuado para suavizar la mecánica y reducir los desgastes producidos por aceleraciones bruscas y cambios repentinos de sentido pero tiene algunas limitaciones.</p>
						<p>La primera es que, tal como está definido, no se tiene en cuenta la altura del producto, del ítem. Por lo cual, al dirigirse hasta la cota Z del sistema de coordenadas empleado por las cintas, esto es, hacia la superficie de las cintas, podemos impactar contra el producto. Para evitarlo, tenemos un parámetro que sería este de aquí: "altura herramienta". Si nos fijamos, el objeto que representa el plato del robot se ilumina en rojo cuando hay un impacto contra otro objeto gráfico, en este caso, el ítem.</p>
						<p>Si aquí indicamos que la altura del ítem son 20 mm, veremos que esta situación cambia y ahora mismo ya nos ilumina en rojo porque estamos dejando el producto a una altura 20 mm de la superficie de la cinta.</p>
						<p>Otra desventaja que tiene este tipo de movimiento curvo es que, en algunas situaciones, puede ser no conveniente. Por ejemplo, porque nos roce el producto con la cinta cuando nos estamos aproximando, o si, por ejemplo, estamos entregando el producto dentro de una caja, pues que los brazos impacten contra las paredes de esta caja. Para evitarlo, tenemos el parámetro "altura obstáculo". Podemos definir una altura de obstáculo para la recogida, por ejemplo, 50 mm, y para la entrega, pues por ejemplo porque tenemos que entregar en una caja que hace 150 mm de alto.</p>
						<p>Vemos que, la trayectoria, automáticamente, se ha modificado. Esta curva se ha deformado para incluir una sección lineal a su inicio y otra también lineal a su fin. Y que esta sección lineal se ejecuta tanto al entrar a buscar el producto como al retirarse. De esta forma, nos estamos acercando y alejando linealmente, perpendicularmente a la cinta, evitando el problema que hemos descrito anteriormente.</p>
						<p>Esto tiene, aunque es positivo, tiene una limitación y es que no estamos utilizando segmentos extras; estamos utilizando el mismo segmento curvo al que estamos deformando la sección inicial y final. Con lo cual, no podemos definir distintas velocidades en distintas zonas de este segmento. No podemos hacer que la sección digamos lineal tenga una velocidad distinta que la curva. Lo máximo que podemos hacer es variar la velocidad a la ida y a la vuelta, pero de toda la trayectoria. Por ejemplo, en la recogida, ya que habitualmente el TCP va sin pieza, podemos hacerla más rápido, por ejemplo, a 600 mm por segundo. Mientras que en la entrega, que es cuando el robot posee la pieza cogida en la herramienta, pues puede interesar hacerlo a una velocidad inferior para evitar que acelerones o brusquedades desprendan la pieza de la herramienta.</p>
						<p>Aquí vemos el efecto en la representación 3D. En un sentido vamos muy rápido y en el otro vamos más lento. No obstante, no podemos modificar la velocidad al aproximarnos para coger la pieza ni al aproximarnos para dejarla. Para hacerlo, tenemos otra opción que sería la de "altura aproximación". Esto sí añade un segmento lineal adicional tanto al inicio como al final de esta trayectoria. Vamos a poner una aproximación de 50 mm tanto a la recogida como a la entrega. Si nos fijamos, vemos que, efectivamente, los últimos 50 mm los hacen a otra velocidad, tanto al coger como al dejar. Eso sí, solamente cuando me estoy aproximando para coger y cuando me estoy aproximando para dejar, pero no al retirarme.</p>
						<p>Esta velocidad se puede modificar a través de parámetros específicos. En este caso, son 20 mm por segundo, muy bajos para que se note la diferencia. Puede ser que nos interese que, al dejar, por ejemplo, imaginemos que estamos dejando no encima de otro producto, sino un poco en el aire, pues no importe tanto esta aproximación. Por tanto, a la entrega podemos hacer que entregue a la misma velocidad de aproximación que la trayectoria.</p>
						<p>En este caso veríamos que toda la trayectoria, incluida la aproximación, que la tiene la hace a igualdad de velocidad, mientras que el camino de picking (de recogida) hace toda la trayectoria a 600, pero los últimos 50 mm los hace a 20 mm por segundo.</p>
						<p>Bien, tenemos también otro parámetro adicional que nos permite crear capas, por eso se llama “altura capa”. Por ejemplo, ahora tenemos que el objeto pues mide 20 mm de alto, pero queremos dejarlos en una caja en varias capas. Por ejemplo, la siguiente capa la podemos dejar a 20 mm más. Si nos fijamos el producto se ha dejado 20 mm por encima del anterior. Podemos ir subiendo a cada viaje. Ahora no nos ha dado tiempo. En el siguiente si nos dará. Y a medida que vamos subiendo, si vemos, la retirada, la retirada que hemos dicho que la caja son 150, se va acortando porque estamos llegando o estamos "comiéndonos" altura de obstáculo. Vamos a ponerle 100.</p>
						<p> Sin embargo, siempre estamos conservando los 50 mm. En este caso, por ejemplo, ahora mismo, tenemos una altura de obstáculo de 150 y una altura de capa, es decir, todos los objetos miden 100. Como la aproximación son 50, 100 + 150 serían igual que la altura de obstáculo. Quiere decir que empiezo a aproximar justo en el borde de la caja. Aun así, puedo hacerlo. Vamos a añadirle 120 mm más. Ahora estamos aproximando ya por encima de la zona del obstáculo.</p>
						<p> Y 140. ahora tenemos una aproximación de 40 mm por encima del obstáculo y 10 dentro del obstáculo y la última, serían 160. En este caso, la aproximación se sigue dando, lo único que hemos fijado una velocidad muy pequeña. Vamos a añadirle otra vez 20 para que se note. Seguimos aproximándonos, pero la retirada, ya que la altura de la última capa está por encima del borde de la caja, tiene lugar sin sección lineal. Es otra vez un spline. ¿Por qué? Porque la aproximación solo tiene lugar cuando me estoy aproximando para dejar el objeto, pero no al retirarme y como me estoy retirando por encima de la altura del obstáculo, no tiene lugar ningún segmento lineal.</p>
						<p>De esta forma, con estos parámetros, podemos modificar tanto las velocidades como el aspecto de la trayectoria que sigue el robot, adaptándonos a todo tipo de aplicaciones o, al menos, a las aplicaciones más comunes. Las que nos podemos encontrar con más asiduidad.</p>	
					</div>
				</section>
				
				<section class="aspectos-container">
					<h3>Aspectos Clave</h3>
					<p><strong>Ubicación:</strong> Dirígete al panel de configuración haciendo clic en el botón correspondiente en el menú lateral izquierdo. Luego, pulsa el botón "Modo Automático" para acceder al panel de configuración de dicho modo, donde encontrarás la sección "Correcciones posiciones". Desde allí, podrás cambiar algunas características de la trayectoria del robot en modo automático.</p>
					<p><strong>Forma trayectoria:</strong> En modo automático, la trayectoria del robot sigue una forma de spline, lo que permite un movimiento más suave y continuo. Esto minimiza el impacto de las aceleraciones bruscas y cambios repentinos de dirección, prolongando la vida útil de los componentes del robot.</p>
					<p><strong>Ajuste trayectoria:</strong> La trayectoria se define referida al plato de montaje de la herramienta (CSR). Así, al acoplar una herramienta y llevar el robot a la cota Z0 esta podría impactar con la cintas. Para evitarlo, podemos elevar las posiciones de recogida y entrega configurando el parámetro "Altura Herramienta" con la altura del gripper más el producto. Con "Altura Obstáculo", podremos definir la altura, respecto a la superficie de las cintas, por debajo de la cual la trayectoria se linearizará para que el robot se aproxime y retire verticalmente durante la recogida y entrega, evitando impactos con la paredes de cajas o productos adyacentes.</p>
					<p><strong>Ajuste velocidades:</strong> Podemos definir distintas velocidades para las fases de recogida y entrega, así como para las aproximaciones. Con "Altura Aproximación", podremos definir la altura, respecto el punto final de la trayectoria, en la que esta se linearizará y adoptará una velocidad de aproximación para un manejo más delicado del producto.</p>
					<p><strong>Creación capas:</strong> El parámetro "Altura Capa" permite ajustar la altura entre capas de productos cuando se apilan en una caja. Esto permite organizar los productos en diferentes niveles y adaptarse a las dimensiones específicas de la caja.</p>
				</section>	
			</article>			

			<!-- Capítulo 19: Funcionalidades IoT -->
			<article class="capitulo-container" id="capitulo19" style="display:none;">
				<iframe 
					src="https://www.youtube.com/embed/p4CCfO8_dn8?modestbranding=1&rel=0&enablejsapi=1"
					frameborder="0"
					loading="lazy"
					allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" 
					allowfullscreen 
					aria-label="Vídeo que describe las posibilidades de conexión de la aplicación con un software basado en nube."> 
				</iframe>

				<section class="transcripcion-container">
					<div class="transcripcion-header" data-leccion="Lección 19">
						<span class="transcripcion-icon" aria-hidden="true">▶</span>
						<span class="transcripcion-text">Transcripción</span>
					</div>
					<div class="transcripcion-content">
						<p>En el presente vídeo hablaremos de las funcionalidades IoT incluidas en la plataforma de desarrollo de aplicaciones multirrobot. Quizás la parte más complicada sea definir para qué vamos a utilizar estas funcionalidades. ¿Las vamos a utilizar para, por ejemplo, mejorar la productividad de la máquina? ¿O para crear un plan más eficiente de mantenimiento? ¿O nuestra intención es crear un nuevo modelo de negocio basado en la servitización?</p>
						<p>En función del objetivo final perseguido, necesitaremos extraer una serie de información de nuestra máquina y, en función de este tipo de información, pues necesitaremos acceder a ciertos datos de ella. Por ejemplo, uno de los datos que podemos encontrar en el panel de configuración es las maniobras OK. ¿Con las maniobras OK podemos crear, por ejemplo, un plan de mantenimiento eficaz? Claramente, no. Por ejemplo, si nuestra intención es cambiar una junta cada 20000 maniobras, el que hayamos hecho 15000 maniobras OK no quiere decir que hayamos hecho, por ejemplo, 6000 que no estén OK. Entonces, este dato por sí mismo, aunque podría llegar a ser utilizado, es insuficiente. Es insuficiente para hacer algún tipo de plan de mantenimiento que sea mínimamente eficaz. Para ello, tendremos que también tener información sobre el dato de maniobras no OK de tal manera que la suma de ambas sí nos dé una idea clara de lo que ha hecho el robot. Por ejemplo, 15000 OK y 5000 no OK serían 20000 maniobras. En este caso, sí podríamos decidir cambiar la junta porque ya he hecho más de las 15000.</p>
						<p>¿Es suficiente? Bueno, siempre se puede ir enriqueciendo esta información. Por ejemplo, si nuestra intención es hacer un estudio de la productividad de la máquina, el saber que la máquina ha hecho 15000 maniobras no nos da idea de la productividad. Esas 15000 maniobras las puede hacer en un minuto, en una hora, en un día... No tenemos la tasa de productividad de la máquina real. Entonces, aquí quizás haría falta también otro dato adicional, que es el tiempo que lleva en producción.</p>
						<p>En fin, estos datos por sí solos, de forma independiente, pueden servir de ayuda o no dependiendo de lo que se esté buscando pero cuanto más valiosos son es cuando se pueden mezclar con otros datos para obtener informaciones más elaboradas.</p>
						<p>La aplicación propuesta propone estos datos. Son muy pocos datos por robot y luego algunos que son más genéricos ¿no? como, por ejemplo, los ítems perdidos por la cinta de recogida o los perdidos por la cinta de entrega. ¿Cómo funciona esto? Bueno, en principio, estos datos se suelen dejar preparados en lo que es la parte superior de la máquina, en el nivel superior, el MainMachine. Aquí, en esta sección de aquí que se llama OPC UA, si nos dirigimos a esta sección, vemos que cogemos variables de la máquina. Aquí, recordemos, se utiliza la variable g_stPD3, y estos datos los cocinamos de alguna manera, los dejamos preparados para subirlos a la capa superior, la capa Gateway, donde ya serán procesados y enviados a un software basado en nube.</p>
						<p>Si nos fijamos, vamos cogiendo datos de máquina, algunos directamente ya son utilizables: se asignan a unas nuevas variables que se han creado para ser subidas a la capa Gateway vía OPC UA, otros se convierten de tipo de variable y otros ya están un poco más cocinados. Por ejemplo, en este caso de aquí, el estado del robot 1, en cada uno de los bits, vemos que el estado del robot 1 es un Word, y cada uno de los bits coge información de bits de la máquina, incluso algunos se hacen algún tipo de operación.</p>
						<p>Vale, entonces, estas variables, que son las que se van a subir, básicamente, estas de aquí, a ver si las marco bien, estas de aquí, estas, están definidas en la carpeta 3 dentro de este bloque de variables globales. Esto es para que sean fácilmente reconocibles. Serían estas de aquí. Estas son las que realmente se van a subir a la capa Gateway vía OPC UA. ¿Cómo se suben? Bien, se suben a través de este otro objeto que es el "Symbol Configuration". Aquí, doble clic y se marcan para ser subidas, simplemente marcándolas, estas variables serán comunicadas hacia el exterior. Y, por supuesto, no nos hemos de olvidar de marcar aquí que queremos activar el servidor OPC UA.</p>
						<p>Bien, hecho esto, estas variables ya se publican hacia un elemento hardware que en este caso es un PC Industrial. Voy a utilizar el mismo PC que estoy utilizando para ver el código de la aplicación, donde se encuentra en este caso concreto, hay muchas formas de hacerlo, un entorno de desarrollo que se llama Node-RED. Vale, entonces, si nos vamos a Node-RED, aquí vemos el programa. Vemos que estas variables se leen a través de una serie de nodos, que vienen dentro del lenguaje Node-RED, y se leen de dos formas distintas: se leen cíclicamente, en este caso, por ejemplo, los datos del robot 1 se leerían cada 30 segundos; y luego, también, hay unas pocas variables que se leen por suscripción, es decir, cuando su valor cambia, lo que serían los estados. En este ejemplo, que también se incluye dentro de la memoria técnica, se han empleado ambos métodos para que se vean claras las dos posibilidades.</p>
						<p>Hay que tener en cuenta que hasta aquí el coste de subir datos hasta lo que es la capa Gateway es gratuito. No importa subir muchos o pocos, pero a partir de este punto, cuando se intenta subir datos a un software basado en nube, estas subidas cuestan un dinero por variable. Es decir, cada vez que subimos una variable, sea del tipo que sea, sea boolean o sea real, da igual, cuesta un…. tiene un coste. Por tanto, hay que estudiar muy bien qué variables vamos a subir y cada cuánto vamos a subirlas. Por tanto, subir todas estas variables cada 30 segundos, dependiendo de lo que queramos conseguir siempre, pues, puede ser aceptable o puede ser excesivamente caro para el objetivo que se pretende. En estos casos, siempre sería mejor utilizar la suscripción. La suscripción también hay que utilizarla con cierta, con cierta inteligencia. No es lo mismo, por ejemplo, subir por suscripción un valor que fluctúa constantemente, por ejemplo, un consumo de un motor, que estaría constantemente modificando su valor y, por tanto, constantemente siendo subido a la nube o, por ejemplo, el modo de trabajo o el número de averías ¿no?, que no suele cambiar muy frecuentemente.</p>
						<p>Bien, de esta manera subimos los dos, aquí juntamos la información, la compactamos en el formato que entiende el software basado en nube y aquí se envía HTTP, utilizando el protocolo HTTP hacia la nube. ¿Por qué? Porque la nube acepta solamente…, el software basado en nube, acepta solamente este formato. Aquí, en la ventana de debug, vemos lo que se está intentando subir. Aquí, digamos, en este payload, lo que hacemos es analizar la respuesta de este nodo y la mostramos aquí ¿vale? así vemos cómo se está subiendo la información empaquetada hacia el software basado en nube.</p>
						<p>Y bien, para acceder al software basado en nube, venimos aquí, abrimos una pestaña en Google, activamos el link que ya tengo preparado, selecciono… este sería la pantalla principal del software basado en nube, donde podemos ver todas las máquinas que tenemos conectadas y esta en concreto, esta de aquí, correspondería al proyecto final de master. Iríamos a monitor y aquí tendríamos el dashboard principal. Esto funciona a través de widgets. Cada información mostrada aquí se obtiene o se representa a través de un widget.</p>
						<p>Lo más importante de todo esto, estaríamos hablando mucho tiempo sobre este software, vamos a hablar de la parte elemental, lo más importante son los valores, lo valores leídos. Si venimos aquí vemos que tenemos valores obtenidos de una calculadora interna, es decir, calculados en la nube y otros que son los que están leídos de la capa inferior, la capa Gateway.</p>
						<p>Vale, a través de los valores leídos es posible extraer más información haciendo cálculos entre ellos. Por eso también a veces es importante, cuando se diseña el sistema, subir solamente datos de tipo básico, de tipo suficiente para extraer información pero que, combinados con otros datos, nos puedan ofrecer más información aún y estos nuevos datos los calcularíamos en la nube para evitarnos el coste de subirlos.</p>
						<p>¿Cómo se calculan? Bueno, los cálculos, normalmente estos softwares suelen ser muy sencillos, los cálculos ni siquiera hay que programar nada ¿no?. Venimos aquí en Calculator; en esta pestaña hay varias posibilidades y en este caso concreto, por ejemplo, esta variable, la R1_OEE, pues venimos aquí a editar y veremos un poco cómo se hace el cálculo. Simplemente añadimos aquí, en el listado de variables, las que queremos utilizar de la lista que hemos visto anteriormente y, a través de una serie de operadores matemáticos, pues nos montamos nuestra fórmula y obtenemos un resultado. Vale, este nuevo valor ¿vale? esta nueva fórmula ¿pues recibe un nombre, que es, bueno, como si fuera un nombre de una variable, y lo podemos utilizar dentro de nuestros widgets.</p>
						<p>En este caso, y como ejemplo, se propone una aplicación, se propone un entorno, basado en tres dashboards: uno principal que nos da una información general del sistema; otro que nos indica, con todos los datos cocinados y en bruto, pues, nos indica una serie de información para extraer el OEE de cada uno de los robots y de esta forma ver formas de mejorar la productividad de cada uno de ellos. Por ejemplo, en este caso veríamos, pues, que el robot 4 tiene una productividad ligeramente inferior a los demás. Podemos estudiar el porqué. Y aquí abajo, pues, tendríamos los datos básicos, los KPI, que forman el OEE ¿vale? los indicadores de proceso, disponibilidad, rendimiento y calidad que, multiplicados entre sí, pues forman el OEE ¿vale? para comprobar, por ejemplo, cuál es el elemento a mejorar.</p>
						<p>En este caso, ya vemos que la disponibilidad del cuarto robot es bastante inferior que el resto mientras que el resto de indicadores son bastante similares. Por tanto, nos centraríamos más en la disponibilidad del cuarto robot más que en la calidad. La calidad, por ejemplo, aquí ya vemos que el cuarto robot es el que se lleva la peor calidad. Pero, estamos hablando de 53 errores frente a 9213 no errores, por tanto, en este caso, aunque si es cierto que el robot 4 tiene una calidad menor, no merece la pena invertir muchos recursos en mejorarla porque son, es, insignificante.</p>
						<p>Con el rendimiento pasa igual. Si es cierto que todos los robots tienen un rendimiento inferior, una producción inferior a la teórica, pero en proporción es más o menos la misma tanto para el robot 1, para el 2, para el 3 o para el 4. También es cierto que para el robot 4 la producción teórica es inferior que la teórica del robot 3 por tanto, es normal que la producción real también sea inferior. Pero en proporción son iguales, por lo tanto, vemos que en cuanto a rendimiento, tampoco hay que invertir muchos recursos en su mejora. Donde realmente hay que mejorar es en la disponibilidad.</p>
						<p>Otro dashboard que tenemos es el de la productividad. Este de aquí. Aquí podemos ver, por ejemplo, datos históricos sobre los ciclos por minuto, pues, de los robots 2, 3 y 4 y vemos que, más o menos, aunque van fluctuando con el tiempo, pues bueno, son similares ¿no?. Y contrastamos esta información con los productos perdidos por las cintas. Vemos que el producto perdido en las cintas de "Place" es solamente uno, mientras que en las cintas de recogida van subiendo con el tiempo hasta llegar al estado actual que serían 636. Esto quiere decir que, de alguna manera, la cinta de… o se están alimentando demasiados ítems o los 4 robots en su conjunto no son capaces de procesar todos los ítems que conlleva la cinta. Por tanto, quizás sería buena idea o bien subir la velocidad de todos los robots o bien bajar la velocidad de la cinta de recogida porque, no estamos cogiendo, no estamos procesando, todos los ítems que están circulando por ahí.</p>
						<p>Y en mantenimiento, si nos interesa realmente mejorar el mantenimiento, pues lo que estamos viendo aquí es los desplazamientos, esos serían datos brutos: el desplazamiento de cada uno de los robots. Vemos que el robot 4 apenas se desplaza. De alguna manera, el robot 4, o no le llegan piezas o tiene algún problema de lentitud que no le hace, no le hace procesar correctamente los ítems que le están llegando. También, el tiempo de producción, vemos que el tiempo de producción del robot 4 también es inferior que el resto. Esto quiere decir que, efectivamente, no es un problema de velocidad sino de que, realmente, no se está moviendo el robot. Es decir, de alguna manera ya no le están llegando piezas al robot número 4, probablemente porque el robot 1, 2 y 3 están absorbiendo toda la producción, mientras que el 4 no está absorbiendo toda la producción.</p>
						<p>En el último gráfico vemos las maniobras. Lo mismo: vemos que las maniobras realizadas por el cuarto robot no son tan elevadas como las realizadas por los anteriores robots. De hecho, de forma muy ligera, vemos que el robot número 1 es el que más trabaja, el robot número 2 trabaja un pelín menos y el robot número 3 trabaja ya un pelín menos pero el 4 ya es exagerado: ya no le llegan ítems. Por tanto, tendríamos que, quizás, buscar métodos para equilibrar el reparto de carga entre los robots.</p>
						<p>Es decir, aquí, para concluir este vídeo, con datos muy simples podemos realizar estudios más o menos elaborados que nos permitan extraer información a largo plazo para mejorar, en este caso, la producción y también mejorar nuestros planes de mantenimiento. No obstante, cada aplicación es un mundo y lo que es la plataforma de desarrollo de aplicaciones multirrobot, pues, incluye una serie de datos pero puede ser que sea necesario el uso de otros datos distintos o, a lo mejor, con los datos que se proponen, simplemente utilizar, pues, 2 o 3 de ellos. Por ejemplo, si quisiéramos crear un modelo de negocio basado en servitización, únicamente necesitaríamos un dato: el número de maniobras OK por ejemplo.</p>
						<p>¿Qué podemos hacer? Pues podemos, por ejemplo, proponer a nuestros clientes, si somos un fabricante de maquinaria, que les vamos a entregar la máquina, la línea robotizada, totalmente gratuita y solo le vamos a cobrar un tanto por ciento por producto OK fabricado. De esta manera él se ahorra la inversión, la gran inversión, de comprar una línea, una línea robotizada, que a lo mejor solo necesita para la presente campaña ¿vale? y a cambio, bueno, nos tendrá que dar un porcentaje de cada pieza fabricada, pero, por contra, él también podrá sacar más margen por cada pieza fabricada porque no tendrá que amortizar esta línea. Por tanto, por un lado, él sale ganando ¿vale? y por otro lado nosotros, como fabricantes de maquinaria, también saldríamos ganando. A la larga recuperaríamos la línea y se la podríamos alquilar, pues, a otro cliente. Eso sería un posible modelo de negocio nuevo. No todo el mundo tiene la inversión o puede permitirse la inversión de comprar una línea entera, a veces, bien, para tenerla en funcionamiento varios años (3, 4 o 5 años) o a veces, simplemente, la necesita para una campaña en concreto o para absorber una punta de trabajo concreta y muchas veces lo que se suele hacer es sobreexplotar las máquinas ya presentes por no comprar una nueva que no justifica el coste para una sola campaña.</p>
						<p>En fin, las funcionalidades IoT permitirían estos nuevos modelos de negocio, así como, por ejemplo, pues mejores o más eficientes técnicas de mantenimiento o incluso estudios de la máquina. Todo depende de lo que se busque con estas funcionalidades nuevas.</p>					</div>
				</section>
				
				<section class="aspectos-container">
					<h3>Aspectos Clave</h3>
<!-- FALTA -->		<p><strong>Objetivos y Utilización de Funcionalidades IoT:</strong> Las funcionalidades IoT en una plataforma de desarrollo de aplicaciones multirrobot deben alinearse con objetivos específicos, como mejorar la productividad, desarrollar planes de mantenimiento eficientes o crear nuevos modelos de negocio. La utilidad de los datos obtenidos depende de los objetivos planteados, y estos datos deben ser combinados adecuadamente para ofrecer información útil.</p>
					<p><strong>Datos Requeridos para Análisis Eficaz:</strong> La calidad del análisis depende de la variedad y precisión de los datos recolectados. Por ejemplo, para un plan de mantenimiento, no solo es importante el número de maniobras OK, sino también el número de maniobras no OK para extraer el porcentaje de efectividad. Para evaluar la productividad, es crucial combinar el número de maniobras con el tiempo de producción. Solo al combinar estos datos se puede obtener una visión completa y precisa.</p>
					<p><strong>Subida y Procesamiento de Datos:</strong> La subida de datos a una capa Gateway y su procesamiento en la nube deben ser gestionados cuidadosamente para optimizar costos. La recopilación cíclica y por suscripción de datos debe ser equilibrada para evitar costos excesivos. Además, el procesamiento en la nube permite realizar cálculos adicionales para generar información más elaborada a partir de datos básicos ahorrando costes al evitar realizar estos cálculos en la capa OT y luego subirlos a la nube.</p>
					<p><strong>Aplicaciones y Modelos de Negocio:</strong> Las funcionalidades IoT permiten no solo mejorar el mantenimiento y la productividad, sino también explorar nuevos modelos de negocio, como la servitización. Por ejemplo, un modelo de negocio basado en cobrar por el uso de una línea robotizada en lugar de venderla, puede ofrecer ventajas tanto para el fabricante como para el cliente, facilitando la inversión en maquinaria de alta tecnología.</p>
				</section>	
			</article>

			<!-- Capítulo 20: Gestión de Recetas -->
			<article class="capitulo-container" id="capitulo20" style="display:none;">
				<iframe 
					src="https://www.youtube.com/embed/mHBnvN01Xr0?modestbranding=1&rel=0&enablejsapi=1"
					frameborder="0"
					loading="lazy"
					allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" 
					allowfullscreen 
					aria-label="Vídeo que muestra las posibilidades de trabajar con recetas incluidas en la aplicación."> 
				</iframe>

				<section class="transcripcion-container">
					<div class="transcripcion-header" data-leccion="Lección 20">
						<span class="transcripcion-icon" aria-hidden="true">▶</span>
						<span class="transcripcion-text">Transcripción</span>
					</div>
					<div class="transcripcion-content">
						<p>En este vídeo veremos las posibilidades del gestor de recetas incluido en la aplicación. Para ello nos dirigiremos al panel de recetas. Este panel muestra los elementos clásicos de un gestor de recetas: una parte central donde se muestra el listado de las recetas disponibles, una parte lateral con los controles para interactuar con el gestor de recetas, una parte superior para buscar recetas y una parte inferior donde nos muestra una información genérica de la receta con la que estamos trabajando, por ejemplo, cuál ha sido la última cargada, su fecha de creación, si se ha grabado correctamente, si se ha leído correctamente.</p>
						<p>¿Qué almacena cada una de estas recetas? Bueno, por defecto almacena todo parámetro incluido en la aplicación. Sin embargo, el contenido de una receta se puede modificar por código dependiendo de las necesidades de la aplicación. Las recetas se guardan con un nombre de usuario, nombre que el usuario le dé de forma alfabética. Como pueden haber hasta 1000 recetas y puede ser complicada la búsqueda de una receta en concreto, sobre todo si se tienen muchas, el buscador de recetas incluye la posibilidad de buscar una receta solo con solo indicando parte del nombre de esta receta.</p>						
						<p>Por ejemplo, si sabemos que nuestra receta empieza con “Receta G” pero no sabemos nada más, podemos utilizar el buscador para que nos diga cuántas recetas empiezan de esta manera. Damos aquí, exactamente nos aparecen cinco. Nos indica que ha encontrado cinco recetas de un total de 1000 posibles recetas. A partir de aquí ya podemos seleccionar la que más nos interesa. Por ejemplo, la cuatro, y darle a cargar. Siempre nos va a pedir confirmación para cualquier operación. Y ya tendríamos cargada la receta de giro síncrono 4. Nos ha indicado también el tiempo de carga, que son 38 milisegundos.</p>
						<p>¿Podemos crear otra receta? Sí, claro, podemos venir aquí, crear una receta nueva. Siempre nos pide confirmación. Y nos la acaba de crear. Se ha refrescado el listado de recetas disponibles y nos muestra aquí que tenemos 21 recetas creadas. ¿Para encontrarla?, pues lo que hemos comentado antes: si ya sabemos el nombre completo, la podemos buscar y solo nos aparecerá una. Y si no lo conocemos al 100%, por ejemplo, solamente una parte, pues también, como solo tenemos una receta que empieza de esta manera, siempre nos muestra una.</p>						
						<p>¿Dónde se guardan estas recetas? Estas recetas se guardan en la memoria del controlador, en la tarjeta de memoria del controlador. Para acceder a estas recetas, hemos de hacer doble clic en el icono “LMC_PacDrive”, nos vamos a la sección “Files”, refrescamos este lado y todo el sistema de recetas se encuentra guardado aquí en “rcp”. Aquí las tenemos. Como vemos, cada receta, y recordemos, cada receta incluye todos los parámetros de la aplicación, solo ocupa 7k. La memoria de este controlador son 128 megabytes, por tanto, es virtualmente imposible alcanzar, con 1000 recetas, alcanzar el tope de la memoria del controlador.</p>
						<p>Teóricamente, deberíamos tener que grabar 128000 recetas. Esto es bastante imposible y nadie trabaja con 1000 recetas. Cada una de las recetas está grabada en formato binario, no es posible ver su contenido. Y si observamos el nombre de la receta guardado, tampoco nos da indicación, por temas de seguridad, del nombre de la receta que hemos utilizado en el estado de recetas.</p>						
						<p>La relación entre el nombre que el usuario le ha dado a la receta y el nombre que el controlador le ha dado al fichero se guarda en este otro fichero, que también es en formato binario y no podemos acceder a él. Si por lo que fuera este fichero se corrompiera, no tendríamos acceso a ninguna de las recetas creadas. Por tanto, se ha añadido la opción de reconstruir. Reconstruir lo que hace es que el sistema se dedica a abrir fichero a fichero y a buscar el nombre codificado del que el usuario le ha dado a esta receta, y va creando una nueva tabla de recetas. De esta forma, podemos recuperar, en caso de corrupción, este fichero.</p>
						<p>Y, en principio, poco más hay que decir. Es un algoritmo que se ha utilizado en múltiples proyectos y que no ha dado jamás ningún problema.</p>						
					</div>
				</section>
				
				<section class="aspectos-container">
					<h3>Aspectos Clave</h3>
					<p><strong>Acceso:</strong> Para acceder al panel de recetas, simplemente haz clic en el botón "Recetas" del menú de navegación lateral izquierdo.</p>
					<p><strong>Funcionalidades:</strong> El panel de recetas ofrece un listado ordenado alfabéticamente e incluye un buscador avanzado que permite localizar recetas utilizando partes del nombre. Además de los típicos controles para crear, editar, cargar y eliminar recetas también posee indicadores para conocer el número de recetas guardadas en memoria y el número de ellas que aparecen en el listado como resultado de una búsqueda.</p>						
					<p><strong>Almacenamiento:</strong> Es posible gestionar hasta 1000 recetas conteniendo cada una el backup de todos los parámetros de la aplicación. Las recetas se guardan en la memoria del controlador en formato binario, lo que impide ver su contenido. </p>
				</section>	
			</article>	
		</section>
		
		<div class="navegacion" role="navigation" aria-label="Controles de navegación">
			<button id="prevBtn" aria-label="Ir a la sección anterior">Anterior</button>
			<button id="nextBtn" aria-label="Ir a la siguiente sección">Siguiente</button>
		</div>
    </main>
	
	<!-- Footer -->
	<footer id="info">
		<nav aria-label="Enlaces legales">
			<ul>
				<li><a href="nota-legal.html">Nota Legal</a></li>
				<li><a href="politica-privacidad.html">Política de Privacidad</a></li>
				<li>
					<a href="https://www.linkedin.com/in/santiagopavía/" target="_blank" rel="noopener noreferrer" aria-label="Perfil de LinkedIn de Santiago Pavía">
						<img src="assets/icons/icons8-linkedin.svg" alt="" aria-hidden="true">
					</a>
				</li>
			</ul>
		</nav>
		<p>&copy; 2024 Portal de Formación PacDrive. Todos los derechos reservados.</p>
	</footer>

    <script src="js/scripts.js"></script>
</body>
</html>
